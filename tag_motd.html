<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head>
<meta http-equiv="Content-type" content="text/html;charset=UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<link rel="stylesheet" href="main.css" type="text/css" />
<link rel="stylesheet" href="blog.css" type="text/css" />
<link rel="alternate" type="application/rss+xml" title="Subscribe to this page..." href="feed.rss" />
<title>Gregg's MOTD &mdash; Posts tagged "motd"</title>
</head><body>
<div id="divbodyholder">
<div class="headerholder"><div class="header">
<div id="title">
<h1 class="nomargin"><a class="ablack" href="http://www.szumowski.org/index.html">Gregg's MOTD</a></h1>
<div id="description">Tips & Tricks that I've Encountered Over the Years...</div>
</div></div></div>
<div id="divbody"><div class="content">
<h3><a class="ablack" href="how-to-use-github-tokens-on-the-command-line1357.html">
How To Use Github Tokens on the Command Line
</a></h3>
<!-- bashblog_timestamp: #202305122120.39# -->
<div class="subtitle">May 12, 2023 &mdash; 
Gregg Szumowski
</div>
<!-- text begin -->

<p>GitHubâ€™s access policy requires you to use tokens instead of username/password to update your repositories. </p>

<p>To adapt your existing local / cloned repos to token based auth:
<br/><code>$ git remote remove origin</code>
<br/><code>$ git remote add origin https://[TOKEN]@github.com/[USER]/[REPO]</code>
<br/><code>$ git push</code>
<br/><br/>
Clone repos using token based authentication (non public repos)</code>
<br/><code>$ git clone https://[username]:[token]@github.com/[accountname]/[reponame]</code>
<br/></p>

<p>Tags: <a href='tag_github.html'>github</a>, <a href='tag_tokens.html'>tokens</a>, <a href='tag_motd.html'>motd</a>, <a href='tag_cli.html'>cli</a></p>
<!-- text end -->
<h3><a class="ablack" href="sending-email-from-the-command-line8566.html">
Sending Email from the Command Line
</a></h3>
<!-- bashblog_timestamp: #202305111815.35# -->
<div class="subtitle">May 11, 2023 &mdash; 
Gregg Szumowski
</div>
<!-- text begin -->

<h4>mutt Examples<br/></h4>

<p>Sending just a file attachment (-a) and an empty message body:<br/>
<br/><code>
$ mutt  -s "System logs" -a /opt/backup.sql -- user@example.com &lt; /dev/null
</code><br/><br/>
Sending a message body using redirection:<br/>
<br/><code>
$ mutt -s "Email subject" test@example.com &lt; email.html
</code><br/><br/>
Sending a file attachment along with a message body:<br/>
<br/><code>
$ echo $message | mutt -s "Subject" -a attachment.txt -- me@myemail.com
</code><br/><br/></p>

<h4>mailx Example:<br/></h4>

<p><br/><code>
$ echo "message body" | mail -s "subject" test@example.com
</code><br/><br/></p>

<p>Tags: <a href='tag_mail.html'>mail</a>, <a href='tag_mutt.html'>mutt</a>, <a href='tag_motd.html'>motd</a></p>
<!-- text end -->
<h3><a class="ablack" href="h1how-to-convert-virtualbox-vdi-to-kvm-qcow2h1.html">
How to convert VirtualBox VDI to KVM qcow2
</a></h3>
<!-- bashblog_timestamp: #202305101707.58# -->
<div class="subtitle">May 10, 2023 &mdash; 
Gregg Szumowski
</div>
<!-- text begin -->

<p>It is easy to convert a VirtualBox VDI image to a KVM qcow2 file. You have to use the RAW file format as an intermediate.</p>

<p>Make sure the VirtualBox machine is shutdown.</p>

<ol>
<li>Convert the VDI to a raw disk image. <br/>
Note: VDIs are compressed and raw images are not, so you will need to leave enough disk space for entire uncompressed disk.<br/>
<br/><code>
$ VBoxManage clonehd --format RAW vm.vdi vm.img
</code><br/><br/></li>
<li>Then on your KVM host:
<br/><code>
$ qemu-img convert -f raw vm.img -O qcow2 vm.qcow2
</code><br/></li>
</ol>

<p>Tags: <a href='tag_virtualization.html'>virtualization</a>, <a href='tag_virtualbox.html'>virtualbox</a>, <a href='tag_kvm.html'>kvm</a>, <a href='tag_qcow2.html'>qcow2</a>, <a href='tag_motd.html'>motd</a></p>
<!-- text end -->
<h3><a class="ablack" href="how-to-count-all-the-files-extension-recursively-in-linux.html">
How To Count All The Files Extension Recursively In Linux
</a></h3>
<!-- bashblog_timestamp: #202305092200.54# -->
<div class="subtitle">May 09, 2023 &mdash; 
Gregg Szumowski
</div>
<!-- text begin -->

<p>To count all the files by file extension recursively on the command line<br/><br/>
<code> $ find . -type f | sed -n 's/..*.//p' | sort | uniq -c </code><br/>
<code>     40 3g2</code><br/>
<code>      5 AVI</code><br/>
<code>     13 DS_Store</code><br/>
<code>     28 JPG</code><br/>
<code>     30 MOV</code><br/>
<code>    133 MP4</code><br/>
<code>     64 THM</code><br/>
<code>      1 docx</code><br/>
<code>     18 jpg</code><br/>
<code>      1 json</code><br/>
<code>      4 m3u</code><br/>
<code>     89 m4a</code><br/>
<code>      2 m4r</code><br/>
<code>    156 m4v</code><br/>
<code>     41 mkv</code><br/>
<code>    112 mov</code><br/>
<code>     38 mp3</code><br/>
<code>    587 mp4</code><br/>
<code>      1 nfo</code><br/>
<code>      2 osp</code><br/>
<code>     30 png</code><br/>
<code>      1 sh</code><br/>
<code>      4 srt</code><br/>
<code>      6 svg</code><br/>
<code>     10 torrent</code><br/>
<code>      6 txt</code><br/>
<code>      5 webm</code><br/>
<code>     10 zip</code><br/>
</code>
<br></p>

<p>Tags: <a href='tag_cli.html'>cli</a>, <a href='tag_motd.html'>motd</a>, <a href='tag_find.html'>find</a>, <a href='tag_sed.html'>sed</a>, <a href='tag_sort.html'>sort</a>, <a href='tag_uniq.html'>uniq</a></p>
<!-- text end -->
<h3><a class="ablack" href="untar-a-tarball-to-a-remote-directory5321.html">
Untar a Tarball to a Remote Directory
</a></h3>
<!-- bashblog_timestamp: #202305081844.08# -->
<div class="subtitle">May 08, 2023 &mdash; 
Gregg Szumowski
</div>
<!-- text begin -->

<p>Sometimes you may need to copy an entire directory structure to another system using the command line. Here is a quick way to do it using the tar command:</p>

<p><code> cat myfile.tgz | ssh user@host "tar xzf - -C /some/dir" </code><br></p>

<p>Tags: <a href='tag_cli.html'>cli</a>, <a href='tag_motd.html'>motd</a>, <a href='tag_tar.html'>tar</a></p>
<!-- text end -->
<h3><a class="ablack" href="gnome3-menu-icons11060.html">
Gnome3 Menu Icons
</a></h3>
<!-- bashblog_timestamp: #202305071706.05# -->
<div class="subtitle">May 07, 2023 &mdash; 
Gregg Szumowski
</div>
<!-- text begin -->

<p>To add your own menu icons to a GNOME3 environment check out this link: 
<a href="https://developer.gnome.org/integration-guide/stable/desktop-files.html.en">Desktop files: putting your application in the desktop menus</a></p>

<p>Tags: <a href='tag_linux.html'>linux</a>, <a href='tag_motd.html'>motd</a></p>
<!-- text end -->
<h3><a class="ablack" href="getting-rid-of-m-line-endings-in-a-text-file20658.html">
Getting Rid of ^M Line Endings in a Text File
</a></h3>
<!-- bashblog_timestamp: #202305061337.12# -->
<div class="subtitle">May 06, 2023 &mdash; 
Gregg Szumowski
</div>
<!-- text begin -->

<p>If you have a text file that has funny looking ^M characters at the end of each line, in most cases, you have to get rid of them before they can be used. This is especially the case when you've copied or transferred a file from a Windows-based system to a *nix-based one. If these files are shell scripts meant to run on the *nix-based system they more often than not won't work. There are various solutions to this problem.</p>

<p>First, let's create two text files: one with ^M line endings and one without:</p>

<p><code> $ for line in 1 2 3 4 5; do echo "This is line ${line}^M" >>file1.txt; done </code><br>
<code> $ for line in 1 2 3 4 5; do echo "This is line ${line}" >>file2.txt; done </code><br></p>

<p>Now let's see what's different between these two text files:</p>

<p><code> $ ls -l </code><br>
<code> total 8 </code><br>
<code> -rw-rw-r--. 1 gszumo gszumo 80 Oct 29 17:43 file1.txt </code><br>
<code> -rw-rw-r--. 1 gszumo gszumo 75 Oct 29 17:44 file2.txt </code><br></p>

<p><code> $ file file1.txt </code><br>
<code> file1.txt: ASCII text, with CRLF line terminators </code><br></p>

<p><code> $ file file2.txt </code><br>
<code> file2.txt: ASCII text </code><br></p>

<p><code> $ diff file1.txt file2.txt </code><br>
<code> 1,5c1,5 </code><br>
<code> &lt; This is line 1 </code><br>
<code> &lt; This is line 2 </code><br>
<code> &lt; This is line 3 </code><br>
<code> &lt; This is line 4 </code><br>
<code> &lt; This is line 5 </code><br>
<code> --- </code><br>
<code> > This is line 1 </code><br>
<code> > This is line 2 </code><br>
<code> > This is line 3 </code><br>
<code> > This is line 4 </code><br>
<code> > This is line 5 </code><br>
<code> $ </code><br></p>

<p>What does this tell us?</p>

<ul>
<li>The ls command tells us the file sizes are different even though the visible text is the same.</li>
<li>The file command tells us that both files are ASCII text  but file1.txt has CRLF line terminators, and</li>
<li>The diff command tells us that each line is indeed showing us that it's different.</li>
</ul>

<p>So, how do we fix this?</p>

<p>My favorite solution is to use vi or vim interactively. There are 2 easy ways to get rid of the ^M from a single file using vim:</p>

<ol>
<li>Enter the command:
<br><code> :%s/^M//g </code><br>
on the vim command line then save the file, or</li>
<li>Enter the command:
<br><code> :fileformat=unix </code><br>
on the vim command line and save the file.</li>
</ol>

<p>However, if you have a whole directory or directory tree full of these kinds of files using vim on each one individually will become quite tedious. For this you need the scripting capability of the command line!</p>

<p>The 'tr' command is one quick way of getting rid of them using the Linux or macOS command line:</p>

<p><code> cat somefile | tr -d '^M' >outputfile </code><br></p>

<p>We can use this as a template in order to determine whether or not the file needs to be updated:</p>

<p><code> for i in * </code><br>
<code> do </code><br>
<code>   string=$(file ${i}) </code><br>
<code>   test "${string#*'CRLF'}" != "$string" &amp;&amp; echo "CRLF found in ${i}" </code><br>
<code> done </code><br></p>

<p>If the 'echo' part of this snippet only gets called when the first part of the test is true, so then we know that the file has '^M' line endings. We have to turn the second part of the test into a script that will massage the file to remove the line endings. Here's a bash snippet that will put the two together and do the job:</p>

<p><code> for i in * </code><br>
<code> do </code><br>
<code>   string=$(file ${i}) </code><br>
<code>   if [ "${string#*'CRLF'}" != "$string" ];then </code><br>
<code>     cp ${i} ${i}.bak </code><br>
<code>     cat ${i}.bak|tr -d '^M' >${i} </code><br>
<code>     rm ${i}.bak </code><br>
<code>   fi </code><br>
<code> done </code><br></p>

<p>This is a bare-bones piece of code which doesn't do any error checking, which should be added in the event that the user running this script doesn't have the necessary permissions to copy, write or remove files that match the test.</p>

<p>Remember, in order to create a '^M' character in the terminal hold down the CTRL key while  typing vm.</p>

<p>You can also use 'ex' to replace a string in a file using:</p>

<p><code> ex -s -c '%s/old-str/new-str/g|x' filename.txt </code><br></p>

<p>Alternately, we can use sed to do the same thing. At the command line you can replace any string in a file dynamically by entering:</p>

<p><code> sed -i 's/old-str/new-str/' filename.txt </code><br></p>

<p>So to remove the ^M charaters just do:</p>

<p><code> sed -i 's/^M//' filename.txt </code><br></p>

<p>to remove the ^M characters. You can use the same for/do/done loop structure as mentioned above to iterate over multiple files:</p>

<p><code> for i in *.txt </code><br>
<code> do </code><br>
<code>   sed -i 's/^M//' ${i} </code><br>
<code> done </code><br></p>

<p>'Nuff said.</p>

<p>Tags: <a href='tag_cli.html'>cli</a>, <a href='tag_motd.html'>motd</a></p>
<!-- text end -->
<h3><a class="ablack" href="removing-m-characters-from-multiple-files19102.html">
Removing ^M Characters From Multiple Files
</a></h3>
<!-- bashblog_timestamp: #202305052225.36# -->
<div class="subtitle">May 05, 2023 &mdash; 
Gregg Szumowski
</div>
<!-- text begin -->

<p>In my day job I find that I frequently need to remove those pesky '^M' line endings from text files that are transferred from one system to the other. Most of the time it is just one file that needs to be fixed so going into vi and typing</p>

<p><code> :%s/^M//g </code><br></p>

<p>solves the problem, but on occasion I might be confronted with performing this process on multiple files and sometimes recursively through many subdirectories. When that happens it becomes necessary to bring out the "big guns" and do:</p>

<p><code> $ for file in $(find /path/to/dir -type f); do </code><br>
<code>       tr -d '\r' <$file >temp.$$ &amp;&amp; mv temp.$$ $file </code><br>
<code>   done </code><br>
<code> $ </code><br></p>

<p>(BTW, to generate a ^M character using the PuTTY emulator is easy. Just press CTRL-^ followed by CTRL-M)</p>

<p>Of course, in Linux, UNIX and AIX shells there are many ways to skin a cat and this is just one of many possible solutions. This solution was found on <a href="https://dailyvim.blogspot.com">a Daily Vim Blogspot site</a> which has more very interesting tips &amp; tutorials.</p>

<p>Tags: <a href='tag_cli.html'>cli</a>, <a href='tag_motd.html'>motd</a></p>
<!-- text end -->
<h3><a class="ablack" href="get-the-hash-of-a-file-on-different-operating-systems17003.html">
Get the Hash of a File on Different Operating Systems
</a></h3>
<!-- bashblog_timestamp: #202305041829.20# -->
<div class="subtitle">May 04, 2023 &mdash; 
Gregg Szumowski
</div>
<!-- text begin -->

<p>Sometimes you just need to hash something. Here are some command lines to do just that.</p>

<p>Windows PowerShell:</p>

<p><code> Get-FileHash C:\path\to\file.iso -Algorithm [MD5|SHA1|SHA256|SHA384|SHA512|MACTripleDES|RIPEMD160] </code><br></p>

<p>(SHA256 is the default if the parameter is omitted) </p>

<p>Linux: </p>

<p><code> md5sum /path/to/file </code><br>
<code> sha1sum /path/to/file </code><br>
<code> sha256sum /path/to/file </code><br></p>

<p>macOS:</p>

<p><code> MD5: md5 /path/to/file </code><br>
<code> SHA1: shasum /path/to/file or shasum -a 1 /path/to/file </code><br>
<code> SHA-256: shasum -a 256 /path/to/file </code><br></p>

<p>Tags: <a href='tag_cli.html'>cli</a>, <a href='tag_motd.html'>motd</a></p>
<!-- text end -->
<h3><a class="ablack" href="copy-entire-directory-structure-using-tar3546.html">
Copy Entire Directory Structure Using Tar
</a></h3>
<!-- bashblog_timestamp: #202305031813.27# -->
<div class="subtitle">May 03, 2023 &mdash; 
Gregg Szumowski
</div>
<!-- text begin -->

<p>Sometimes you need to copy an entire directory structure to another location on the command line. Here is a quick way to do it using the tar command:</p>

<p><code> tar cf - * | ( cd /target; tar xfp -) </code><br></p>

<p>Tags: <a href='tag_cli.html'>cli</a>, <a href='tag_motd.html'>motd</a></p>
<!-- text end -->
<h3><a class="ablack" href="fixing-screen-resolution-on-second-monitor-in-linux4621.html">
Fixing Screen Resolution on Second Monitor in Linux
</a></h3>
<!-- bashblog_timestamp: #202305021816.35# -->
<div class="subtitle">May 02, 2023 &mdash; 
Gregg Szumowski
</div>
<!-- text begin -->

<p>I recently installed a 2nd hard drive in my Macbook Pro dedicated to Linux. When I hooked up a secondary monitor to it I found that I could not get a reasonable resolution. After some research I found that I can add a new mode to the "Display" choices by entering the following in a terminal console:</p>

<p><code> xrandr </code> # to find the device name <br>
<code> cvt 1920 1080 </code> # to generate the mode for the xrandr program. <br>
<code> xrandr --newmode "1920x1080<em>60.00" 173.00 1920 2048 2248 2576 1080 1083 1088 1120 -hsync +vsync </code> # to add the new mode to the monitor choices. <br>
<code>xrandr --addmode DP1 1920x1080</em>60.00 </code> # to associate the new mode to the monitor.   <br></p>

<p>Tags: <a href='tag_linux.html'>linux</a>, <a href='tag_motd.html'>motd</a></p>
<!-- text end -->
<h3><a class="ablack" href="sort-directory-by-file-size1118.html">
Sort Directory by File Size
</a></h3>
<!-- bashblog_timestamp: #202305012215.27# -->
<div class="subtitle">May 01, 2023 &mdash; 
Gregg Szumowski
</div>
<!-- text begin -->

<p>To sort files in a directory and to list them by the biggest file first:<br>
<code>
$ du -a | sort -n -r | more
</code>
<br>Alternatively you can use:<br>
<code>
$ du -s * | sort -n -r | more
</code>
<br></p>

<p>Tags: <a href='tag_cli.html'>cli</a>, <a href='tag_motd.html'>motd</a></p>
<!-- text end -->
<h3><a class="ablack" href="talkin-trash19647.html">
Talkin' Trash
</a></h3>
<!-- bashblog_timestamp: #202304291129.11# -->
<div class="subtitle">April 29, 2023 &mdash; 
Gregg Szumowski
</div>
<!-- text begin -->

<p>Having trouble getting the "Empty Trash" working in Thunar? Remove <code>"~/.config/xfce4/xfconf/xfce-perchannel-xml/thunar*"</code>.</p>

<p>Tags: <a href='tag_linux.html'>linux</a>, <a href='tag_motd.html'>motd</a></p>
<!-- text end -->
<h3><a class="ablack" href="uptime-statistics-for-windows.html">
Uptime Statistics for Windows
</a></h3>
<!-- bashblog_timestamp: #202304251728.42# -->
<div class="subtitle">April 25, 2023 &mdash; 
Gregg Szumowski
</div>
<!-- text begin -->

<p>To find the uptime for a Windows machine do</p>

<p><code>
C:&gt; net statistics server
</code></p>

<p>Tags: <a href='tag_windows.html'>windows</a>, <a href='tag_motd.html'>motd</a></p>
<!-- text end -->
<h3><a class="ablack" href="alternative-to-using-cp.html">
Alternative to Using cp
</a></h3>
<!-- bashblog_timestamp: #202304242208.12# -->
<div class="subtitle">April 24, 2023 &mdash; 
Gregg Szumowski
</div>
<!-- text begin -->

<p>To backup files from a source directory to a backup directory:
<code>
$ mkdir /path/to/backup/directory
$ cd $HOME/source/directory
$ tar cf - . | (cd /path/to/backup/directory &amp;&amp; tar xBvf -)
</code>
Define the following alias:</p>

<p><code>
tar cvf - . | ( cd \!* ; tar xvf - )
</code></p>

<p>or as an alias:</p>

<p><code>
alias cpbytar='tar cvf - . | ( cd \!* ; tar xvf - )'
</code>
(The alias definition above is for Bash)</p>

<p>To do a recursive copy of a directory to another location, preserving the PERMISSIONS and OWNERSHIP of the files.  "cd" to the source location and invoke the following alias:</p>

<p><code>
cpbytar
</code></p>

<p>Tags: <a href='tag_cli.html'>cli</a>, <a href='tag_motd.html'>motd</a></p>
<!-- text end -->
<h3><a class="ablack" href="git-tips.html">
git Tips
</a></h3>
<!-- bashblog_timestamp: #202304151337.14# -->
<div class="subtitle">April 15, 2023 &mdash; 
Gregg Szumowski
</div>
<!-- text begin -->

<p>A useful tip to beautify your output is to use:
<code>
$ git log --graph --decorate --oneline --abbrev-commit --all --date=local
</code>
when looking at your log entries.
Or you can add
<code>
[alias]
</code>
<code>
   lola = log --graph --decorate --pretty=oneline --abbrev-commit --all --date=local
</code>
to your ~/.gitconfig file to use <code>$ git lola</code> as an alias.</p>

<p>Tags: <a href='tag_git.html'>git</a>, <a href='tag_motd.html'>motd</a></p>
<!-- text end -->
</div>
<div id="footer">CC by-nc-nd <a href="http://twitter.com/gszumo">Gregg Szumowski</a> &mdash; <a href="mailto:gszumo[at]gmail[dot]com">gszumo[at]gmail[dot]com</a> &mdash; <a rel="me" href="https://mastodon.sdf.org/@gszumo">Mastodon</a><br/>
NOTE: All tips provided are USE AT YOUR OWN RISK. It is suggested that you read and test each tip in a non-volitile environment before placing into production.<br/>
Generated with <a href="https://github.com/cfenollosa/bashblog">bashblog</a>, a single bash script to easily create blogs like this one</div>
</div></div>
</body></html>
