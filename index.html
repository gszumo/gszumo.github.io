<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head>
<meta http-equiv="Content-type" content="text/html;charset=UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<link rel="stylesheet" href="main.css" type="text/css" />
<link rel="stylesheet" href="blog.css" type="text/css" />
<link rel="alternate" type="application/rss+xml" title="Subscribe to this page..." href="feed.rss" />
<title>Gregg's MOTD</title>
</head><body>
<div id="divbodyholder">
<div class="headerholder"><div class="header">
<div id="title">
<h1 class="nomargin"><a class="ablack" href="http://www.szumowski.org/index.html">Gregg's MOTD</a></h1>
<div id="description">Tips & Tricks that I've Encountered Over the Years...</div>
</div></div></div>
<div id="divbody"><div class="content">
<h3><a class="ablack" href="use-the-zdump-command-to-check-daylight-savings-time-settings.html">
Use the zdump Command to Check Daylight Savings Time Settings
</a></h3>
<!-- bashblog_timestamp: #202308241824.59# -->
<div class="subtitle">August 24, 2023 &mdash; 
Gregg Szumowski
</div>
<!-- text begin -->
<p>If you are one of us <em>lucky</em> folks who live in timezones that
observe <em>Daylight Savings Time</em>, you can use the
<code>zdump</code> timezone dumper command to view your server’s
settings for same. This command prints the current time in each timezone
provided on the command line.</p>
<p>You can use <code>grep</code> to reduce the output to just the lines
that reference the current year:</p>
<blockquote>
<p><code>$ zdump -v EST5EDT |grep '2023'</code><br/>
<code>EST5EDT  Sun Mar 12 06:59:59 2023 UT = Sun Mar 12 01:59:59 2023 EST isdst=0 gmtoff=-18000</code><br/>
<code>EST5EDT  Sun Mar 12 07:00:00 2023 UT = Sun Mar 12 03:00:00 2023 EDT isdst=1 gmtoff=-14400</code><br/>
<code>EST5EDT  Sun Nov  5 05:59:59 2023 UT = Sun Nov  5 01:59:59 2023 EDT isdst=1 gmtoff=-14400</code><br/>
<code>EST5EDT  Sun Nov  5 06:00:00 2023 UT = Sun Nov  5 01:00:00 2023 EST isdst=0 gmtoff=-18000</code><br/></p>
</blockquote>
<p>You can also run the same command by location:</p>
<blockquote>
<p><code>$ zdump -v /usr/share/zoneinfo/America/New_York|grep '2023'</code><br/>
<code>/usr/share/zoneinfo/America/New_York  Sun Mar 12 06:59:59 2023 UT = Sun Mar 12 01:59:59 2023 EST isdst=0 gmtoff=-18000</code><br/>
<code>/usr/share/zoneinfo/America/New_York  Sun Mar 12 07:00:00 2023 UT = Sun Mar 12 03:00:00 2023 EDT isdst=1 gmtoff=-14400</code><br/>
<code>/usr/share/zoneinfo/America/New_York  Sun Nov  5 05:59:59 2023 UT = Sun Nov  5 01:59:59 2023 EDT isdst=1 gmtoff=-14400</code><br/>
<code>/usr/share/zoneinfo/America/New_York  Sun Nov  5 06:00:00 2023 UT = Sun Nov  5 01:00:00 2023 EST isdst=0 gmtoff=-18000</code><br/></p>
</blockquote>
<p>Tags: <a href='tag_cli.html'>cli</a>, <a href='tag_zdump.html'>zdump</a>, <a href='tag_timezones.html'>timezones</a>, <a href='tag_motd.html'>motd</a></p>
<!-- text end -->
<h3><a class="ablack" href="logging-to-the-system-logger-in-bash17599.html">
Logging to the System Logger in Bash
</a></h3>
<!-- bashblog_timestamp: #202308231801.59# -->
<div class="subtitle">August 23, 2023 &mdash; 
Gregg Szumowski
</div>
<!-- text begin -->
<p>If you are writing a shell script and want any messages to appear in
the system logger you can just use the <code>logger</code> command to do
this.</p>
<p>Here is an example on my Slackware system:</p>
<blockquote>
<p><code>$ logger -t TEST "This is a test message"</code><br/>
<code>$ cat /var/log/messages</code><br/>
<code>cat: /var/log/messages: Permission denied</code><br/>
<code>$ su -</code><br/> <code>Password:</code><br/>
<code># cat /var/log/messages</code><br/>
<code>Aug 23 17:44:47 slackbook TEST: This is a test message</code><br/></p>
</blockquote>
<p>You can also log to <em>systemd</em> by providing a parameter to
<em>logger</em>:</p>
<blockquote>
<p><code>logger --journald &lt;&lt;end</code><br/>
<code>MESSAGE_ID=67feb6ffbaf24c5cbec13c008dd72309</code><br/>
<code>MESSAGE=The dogs bark, but the caravan goes on.</code><br/>
<code>DOGS=bark</code><br/> <code>CARAVAN=goes on</code><br/>
<code>end</code><br/></p>
</blockquote>
<p>or you can optionally provide a file whose contents will be
logged:</p>
<blockquote>
<p><code>logger --journald=entry.txt</code><br/></p>
</blockquote>
<p>See the <em>logger</em> manpage for additional information.</p>
<p>Tags: <a href='tag_cli.html'>cli</a>, <a href='tag_logging.html'>logging</a>, <a href='tag_systemd.html'>systemd</a>, <a href='tag_logger.html'>logger</a>, <a href='tag_motd.html'>motd</a></p>
<!-- text end -->
<h3><a class="ablack" href="encrypting-files-using-openssl23222.html">
Encrypting Files using OpenSSL
</a></h3>
<!-- bashblog_timestamp: #202308221918.26# -->
<div class="subtitle">August 22, 2023 &mdash; 
Gregg Szumowski
</div>
<!-- text begin -->
<p>Let’s say we have a file that contains sensitive information and we
want to encyrpt it. You can encrypt a file very easily using the
<code>openssl</code> command:</p>
<blockquote>
<p><code>$ cat secret.txt</code><br/>
<code>This file contains some very secret stuff</code><br/>
<code>$ openssl enc -e -aes-256-cbc -pbkdf2 -a -salt -in secret.txt -out secret.enc</code><br/>
<code>enter aes-256-cbc encryption password: &lt;enter-a-password&gt;</code><br/>
<code>Verifying - enter aes-256-cbc encryption password:  &lt;enter-a-password&gt;</code><br/>
<code>$ cat secret.enc</code><br/>
<code>U2FsdGVkX19Rnz48WjLeljd19wvNOhQy+zzYwxCANezCTkqpGMl9zs4HdwdUzZjl</code><br/>
<code>VQkUsCJ7b0rUpRi83UlcwA==</code><br/></p>
</blockquote>
<p>Now we decrypt it (output to a different file). Make sure you enter
the same password that you input above:</p>
<blockquote>
<p><code>$ openssl enc -d -aes-256-cbc -pbkdf2 -a -salt -in secret.enc -out unencrypted-secret.txt</code><br/>
<code>enter aes-256-cbc decryption password:  &lt;enter-a-password&gt;</code><br/>
<code>$ cat unencrypted-secret.txt</code><br/>
<code>This file contains some very secret stuff</code><br/>
<code>$</code><br/></p>
</blockquote>
<p>Tags: <a href='tag_cli.html'>cli</a>, <a href='tag_openssl.html'>openssl</a>, <a href='tag_encryption.html'>encryption</a>, <a href='tag_motd.html'>motd</a></p>
<!-- text end -->
<h3><a class="ablack" href="finding-the-ssl-directory-on-a-server32368.html">
Finding the SSL Directory on a Server
</a></h3>
<!-- bashblog_timestamp: #202308211917.05# -->
<div class="subtitle">August 21, 2023 &mdash; 
Gregg Szumowski
</div>
<!-- text begin -->
<p>I’ve had situations where I was configuring a secure connection to an
application and needed to know where the SSL certificates are stored on
the server. You can easily find out this information using the
<code>openssl</code> and <code>grep</code> commands:</p>
<blockquote>
<p><code>$ openssl version -a | grep OPENSSLDIR</code><br/>
<code>OPENSSLDIR: "/etc/pki/tls"</code><br/></p>
</blockquote>
<p>Tags: <a href='tag_cli.html'>cli</a>, <a href='tag_ssl.html'>ssl</a>, <a href='tag_openssl.html'>openssl</a>, <a href='tag_motd.html'>motd</a></p>
<!-- text end -->
<h3><a class="ablack" href="processing-the-results-of-the-find-command10607.html">
Processing The Results of The Find Command
</a></h3>
<!-- bashblog_timestamp: #202308191318.54# -->
<div class="subtitle">August 19, 2023 &mdash; 
Gregg Szumowski
</div>
<!-- text begin -->
<p>As mentioned in the previous post, the find command searches for
files, but it has another very useful feature in that it can also
perform an action on the files it finds.</p>
<p>I am a <em>vim</em> user, and let’s assume that I want to find my
editor’s backup files in the current directory trees. These filesall end
with a tilda (~) character. We would use this command to search for
them:</p>
<blockquote>
<p><code>$ find . -name '*~'</code><br/> <code>./.buffer.un~</code><br/>
<code>./.find_buffer.txt.un~</code><br/>
<code>./.Tips.txt.un~</code><br/></p>
</blockquote>
<p>which results in a list of 3 files. All it takes to remove these
files is to add on a little to the end of the last command:</p>
<blockquote>
<p><code>$ find . -name '*~' -exec rm -i '{}' \;</code><br/></p>
</blockquote>
<p>Now, not only will this command find all the matching files in the
current directory tree, but it will also delete them.</p>
<p>The <code>-exec</code> parameter tells <code>find</code> to
<em>execute</em> the command that follows it on each result. The string
<code>{}</code> is replaced by the current file name being processed
everywhere it occurs in the arguments to the command. The
<code>{}</code> string is enclosed in single quotes to protect them from
interpretation as shell script punctuation. The <code>\;</code> sequence
indicates the end of the <code>-exec</code> argument.</p>
<p>See the manpage for more information.</p>
<p>Tags: <a href='tag_cli.html'>cli</a>, <a href='tag_find.html'>find</a>, <a href='tag_motd.html'>motd</a></p>
<!-- text end -->
<h3><a class="ablack" href="using-the-find-command-to-search-for-files28509.html">
Using the Find Command to Search for Files
</a></h3>
<!-- bashblog_timestamp: #202308181704.01# -->
<div class="subtitle">August 18, 2023 &mdash; 
Gregg Szumowski
</div>
<!-- text begin -->
<p>One of the most useful and flexible GNU utilities is the
<em>find</em> command. Understanding how to use this command is very
important to make you Linux life more efficient.</p>
<p>The general syntax of the find command is:</p>
<blockquote>
<p><code>find [-H] [-L] [-P] [-D debugopts] [-Olevel] [starting-point...] [expression]</code><br/></p>
</blockquote>
<p>That looks like a lot, but most of the time you may only need 2
things:</p>
<blockquote>
<p><code>find [path] [expression]</code><br/></p>
</blockquote>
<p>where the <em>path</em> is a starting point or the top of a directory
tree to be searched, and <em>expression</em> is a property and value
pair of what you’re trying to find. This may be a file name, last access
time, last modification time, size, and/or ownership.</p>
<p>For example, if you’re looking for the file stdlib.h, use the
following command:</p>
<blockquote>
<p><code>find / -name stdlib.h</code><br/></p>
</blockquote>
<p>If you run this as a <em>normal</em> user, using <em>find</em> from
the <em>root</em> directory will often result in a lot of error messages
being output to the terminal because the <em>normal</em> user doesn’t
have access to view some of the directories in the search. Therefore you
may want to pipe the <em>stderr</em> output to <code>/dev/null</code> to
avoid seeing those messages. You can do that like this:</p>
<blockquote>
<p><code>find / -name stdlib.h 2&gt;/dev/null</code><br/></p>
</blockquote>
<p>Tags: <a href='tag_cli.html'>cli</a>, <a href='tag_find.html'>find</a>, <a href='tag_motd.html'>motd</a></p>
<!-- text end -->
<h3><a class="ablack" href="git-aliases20780.html">
Git Aliases
</a></h3>
<!-- bashblog_timestamp: #202308171728.22# -->
<div class="subtitle">August 17, 2023 &mdash; 
Gregg Szumowski
</div>
<!-- text begin -->
<p>Once you start developing some experience with using <em>git</em> on
the command line, you will sometimes find yourself typing some long
commands over and over again. You can create <em>aliases</em> in
<em>git</em> that are very similar to the <em>bash alias</em> shortcuts
you use in the shell.</p>
<p>Steps to do this are highlighted in chapter 2.7 of the <a
href="https://git-scm.com/book/en/v2/Git-Basics-Git-Aliases">Git
Book</a> authored by Scott Chacon and Ben Straub and published by
Apress.</p>
<p>One of the commands that I use a lot is:</p>
<blockquote>
<p><code>$ git log --graph --decorate --pretty=oneline --abbrev-commit --all --date=local</code><br/></p>
</blockquote>
<p>which provides a nice colorized listing of the project’s activity and
looks something like this:</p>
<blockquote>
<p><code>*   2f6cc07 (HEAD -&gt; automation, origin/master, origin/HEAD, master) Updated merge for README.md</code><br/>
<code>|\</code><br/> <code>| * 84e20c2 Initial commit</code><br/>
<code>* 8dc456f Completed migration for github site.</code><br/>
<code>* bf67601 fixed head before sed</code><br/>
<code>*   89780c3 Merge pull request #124 from thalios1973/feat/pandoc-test-fix</code><br/>
<code>|\</code><br/>
<code>| * c9a297c Added additional check that will allow the use of pandoc without the --strict flag or 'hsmarkdown' hack.</code><br/>
<code>* |   025cf79 Merge pull request #125 from thalios1973/feat/body-end-file</code><br/>
<code>|\ \</code><br/> <code>| |/</code><br/> <code>|/|</code><br/>
<code>| * 272b1b6 Added ability to include custom code just before the &lt;/body&gt; tag. body_end_file global config variable added.</code><br/>
<code>|/</code><br/> <code>* 9f66ad0 README formatting</code><br/>
<code>* 500253e Support for static, not managed by bashblog html files. Close #92</code><br/>
<code>* 3c73ef6 Deleted the now defunct Twitter JSON API for share count. Fix #117</code><br/>
<code>* b5a4590 bump version to 2.8</code><br/>
<code>* 5c8e0e5 Revert changes in #116</code><br/>
<code>*   5fc037f Merge branch 'master' of github.com:cfenollosa/bashblog</code><br/>
<code>|\</code><br/>
<code>| * c6a9bef Revert tag management from #116</code><br/>
<code>| * 6222672 Better error message for $EDITOR. Close #112</code><br/>
<code>| * 36d79b5 support Markdown.pl in bashblog folder. Close #113</code><br/>
<code>| *   7154c07 Merge pull request #116 from McDutchie/master</code><br/>
<code>| |\</code><br/>
<code>| | * f50a17c tags_in_post(): bugfix for non-GNU 'sed'</code><br/>
<code>| | * 2a29b22 Fix renaming using 'bb.sh edit -n'. Suppress 'which' errmsg.</code><br/>
<code>| | *   62a26bb Merge remote-tracking branch 'upstream/master' Resolve minor editing 2.6-to-2.7 editing conflict in bb.sh</code><br/>
<code>| | |\</code><br/>
<code>| | * | 54cc0c8 More code refactoring. Limit word splitting and disable globbing by default.</code><br/>
<code>| | * |   d1a84d6 Merge remote-tracking branch 'upstream/master'</code><br/>
<code>| | |\ \</code><br/>
<code>| | * | | a674ec5 rebuild_tags(): use array for more robust file handling</code><br/>
<code>| * | | | 2157b92 Slavic language support, thanks to Tomasz Jadowski</code><br/>
<code>| | |_|/</code><br/> <code>| |/| |</code><br/></p>
</blockquote>
<p>but nicer than this website can depict (for now).</p>
<p>Rather than typing this long command every time, I just create an
alias:</p>
<blockquote>
<p><code>$ git config --global alias.lola 'log --graph --decorate --pretty=oneline --abbrev-commit --all --date=local'</code><br/></p>
</blockquote>
<p>Then all I need to type from now on is:</p>
<blockquote>
<p><code>$ git lola</code><br/></p>
</blockquote>
<p>Tags: <a href='tag_cli.html'>cli</a>, <a href='tag_git.html'>git</a>, <a href='tag_aliases.html'>aliases</a>, <a href='tag_motd.html'>motd</a></p>
<!-- text end -->
<h3><a class="ablack" href="setting-up-git-to-ignore-elf-binaries-cc-output-on-linux.html">
Setting Up Git to Ignore ELF Binaries (C/C++ Output on Linux)
</a></h3>
<!-- bashblog_timestamp: #202308161701.04# -->
<div class="subtitle">August 16, 2023 &mdash; 
Gregg Szumowski
</div>
<!-- text begin -->
<p>The starting point for this experiment was from <a
href="https://stackoverflow.com/questions/5711120/gitignore-binary-files-that-have-no-extension">here</a></p>
<p><strong>An Example using C Program Source</strong></p>
<p>Let’s say we have a pre-existing directory of some C source code
files:</p>
<blockquote>
<p><code>$ ls</code><br/>
<code>Makefile  print  print.c  print.h  print.o</code><br/></p>
</blockquote>
<p>And we initialize a new git repository in that directory:</p>
<blockquote>
<p><code>$ git init</code><br/>
<code>Initialized empty Git repository in /home/user/tmp/printer/.git/</code><br/>
<code></code><br/> <code>$ cat .gitignore</code><br/>
<code># Ignore all</code><br/> <code>*</code><br/> <code></code><br/>
<code># Unignore all with extensions</code><br/> <code>!*.*</code><br/>
<code></code><br/> <code># Unignore all dirs</code><br/>
<code>!*/</code><br/> <code></code><br/>
<code># Unignore make files</code><br/> <code>!Makefile</code><br/>
<code></code><br/> <code># Ignore .o files</code><br/>
<code>*.o</code><br/> <code></code><br/>
<code># Ignore</code>bin<code>dir</code><br/> <code>bin/</code><br/>
<code># or</code><br/> <code>*/bin/*</code><br/></p>
</blockquote>
<p>Let’s see how we did:</p>
<blockquote>
<p><code>$ git status</code><br/> <code>On branch master</code><br/>
<code></code><br/> <code>No commits yet</code><br/> <code></code><br/>
<code>Untracked files:</code><br/>
<code>(use "git add &lt;file&gt;..." to include in what will be committed)</code><br/>
<code>.gitignore</code><br/> <code>Makefile</code><br/>
<code>print.c</code><br/> <code>print.h</code><br/> <code></code><br/>
<code>nothing added to commit but untracked files present (use "git add" to track)</code><br/></p>
</blockquote>
<p>So the <code>print</code> and the <code>print.o</code> files are not
showing up, which was our initial goal.</p>
<p>You may have to <em>tweak</em> the settings in the above
<code>.gitignore</code> file to your own situation, but as you can see
it is possible to setup <em>git</em> to ignore the ELF binaries output
by <em>gcc</em>. I would probably also add <code>a.out</code> to the
list of <em>unignored</em> files just to cover those times when you’re
not using a <code>Makefile</code>. YMMV.</p>
<p>Tags: <a href='tag_cli.html'>cli</a>, <a href='tag_git.html'>git</a>, <a href='tag_gcc.html'>gcc</a>, <a href='tag_motd.html'>motd</a></p>
<!-- text end -->
<div id="all_posts"><a href="all_posts.html">View more posts</a> &mdash; <a href="all_tags.html">All tags</a> &mdash; <a href="feed.rss">Subscribe</a></div>
</div>
<div id="footer">CC by-nc-nd <a href="http://twitter.com/gszumo">Gregg Szumowski</a> &mdash; <a href="mailto:gszumo[at]gmail[dot]com">gszumo[at]gmail[dot]com</a> &mdash; <a rel="me" href="https://mastodon.sdf.org/@gszumo">Mastodon</a><br/>
NOTE: All tips provided are USE AT YOUR OWN RISK. It is suggested that you read and test each tip in a non-volitile environment before placing into production.<br/>
Generated with <a href="https://github.com/cfenollosa/bashblog">bashblog</a>, a single bash script to easily create blogs like this one</div>
</div></div>
</body></html>
