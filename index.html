<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head>
<meta http-equiv="Content-type" content="text/html;charset=UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<link rel="stylesheet" href="main.css" type="text/css" />
<link rel="stylesheet" href="blog.css" type="text/css" />
<link rel="alternate" type="application/rss+xml" title="Subscribe to this page..." href="feed.rss" />
<title>Gregg's MOTD</title>
</head><body>
<div id="divbodyholder">
<div class="headerholder"><div class="header">
<div id="title">
<h1 class="nomargin"><a class="ablack" href="http://www.szumowski.org/index.html">Gregg's MOTD</a></h1>
<div id="description">Tips & Tricks that I've Encountered Over the Years...</div>
</div></div></div>
<div id="divbody"><div class="content">
<h3><a class="ablack" href="rename-files-that-start-with-a-special-character22468.html">
Rename Files That Start With a Special Character
</a></h3>
<!-- bashblog_timestamp: #202307131839.20# -->
<div class="subtitle">July 13, 2023 &mdash; 
Gregg Szumowski
</div>
<!-- text begin -->
<p>Suppose you find that you have a file with a <em>special</em>
character and you want to delete it:</p>
<blockquote>
<p><code>$ ls</code><br/>
<code>-badfile.txt              PrintHood                   reg57.txt</code><br/>
<code>Favorites                 Recent                      scripts</code><br/>
<code></code><br/> <code>$ rm -badfile.txt</code><br/>
<code>rm: invalid option -- 'b'</code><br/>
<code>Try 'rm ./-badfile.txt' to remove the file '-badfile.txt'.</code><br/>
<code>Try 'rm --help' for more information.</code><br/>
<code></code><br/> <code>$ ls *.txt</code><br/>
<code>ls: invalid option -- 'e'</code><br/>
<code>Try 'ls --help' for more information.</code><br/></p>
</blockquote>
<p>First, find the <code>inode</code> of the file by using
<code>ls -i</code> on the command line:</p>
<blockquote>
<p><code>$ ls -i</code><br/>
<code>54804119 -badfile.txt                56634824 PrintHood</code><br/>
<code>56634825 Recent                      56634807 Favorites</code><br/>
<code>54804251 reg57.txt                   56634833 scripts</code><br/></p>
</blockquote>
<p>The “-i” flag will display the file’s inode:<br/> <em>54804119</em>
-badfile.txt</p>
<p>The inode for the “bad” file is <em>54804119</em>. Once the inode is
identified, use the find command to rename the file:</p>
<blockquote>
<p><code>$ find . -inum 54804119 -exec mv {} NewName \;</code><br/>
<code></code><br/> <code>$ ls NewName</code><br/>
<code>NewName</code><br/></p>
</blockquote>
<p>Now you can delete it.</p>
<blockquote>
<p><code>$ rm NewName</code><br/></p>
</blockquote>
<p>Tags: <a href='tag_cli.html'>cli</a>, <a href='tag_rename.html'>rename</a>, <a href='tag_find.html'>find</a>, <a href='tag_inode.html'>inode</a>, <a href='tag_motd.html'>motd</a></p>
<!-- text end -->
<h3><a class="ablack" href="scping-files-using-a-text-file-list.html">
scp’ing Files using a Text File List
</a></h3>
<!-- bashblog_timestamp: #202307121810.28# -->
<div class="subtitle">July 12, 2023 &mdash; 
Gregg Szumowski
</div>
<!-- text begin -->
<p>If you have a collection of files that you want to transfer to a
remote server and they are a subset of files in the current directory or
scattered among different directories you can create a list of files and
then pipe the list to <code>scp</code>:</p>
<blockquote>
<p><code>$ cat filelist.txt | xargs -i scp {} user@remote:~/backup/</code><br/></p>
</blockquote>
<p>Tags: <a href='tag_cli.html'>cli</a>, <a href='tag_xargs.html'>xargs</a>, <a href='tag_scp.html'>scp</a>, <a href='tag_motd.html'>motd</a></p>
<!-- text end -->
<h3><a class="ablack" href="how-to-recursively-find-the-latest-modified-file-in-a-directory.html">
How to recursively find the latest modified file in a directory
</a></h3>
<!-- bashblog_timestamp: #202307111728.59# -->
<div class="subtitle">July 11, 2023 &mdash; 
Gregg Szumowski
</div>
<!-- text begin -->
<blockquote>
<p><code>find . -type f -printf '%T@ %p\n' | sort -n | tail -1 | cut -f2- -d" "</code><br/></p>
</blockquote>
<p>Tags: <a href='tag_cli.html'>cli</a>, <a href='tag_find.html'>find</a>, <a href='tag_sort.html'>sort</a>, <a href='tag_tail.html'>tail</a>, <a href='tag_cut.html'>cut</a>, <a href='tag_motd.html'>motd</a></p>
<!-- text end -->
<h3><a class="ablack" href="bind-to-a-remote-port-using-ssh22839.html">
Bind to a Remote Port Using SSH
</a></h3>
<!-- bashblog_timestamp: #202307101810.28# -->
<div class="subtitle">July 10, 2023 &mdash; 
Gregg Szumowski
</div>
<!-- text begin -->
<p>If you are trying to access the web page of an application running on
a remote machine and you find that you are blocked, you can bind to it
using SSH with similar parameters to this:</p>
<blockquote>
<p><code>$ ssh pi@raspberrypi.local -L 8384:127.0.0.1:8384 -N</code><br/></p>
</blockquote>
<p>Where:</p>
<ul>
<li><code>pi@raspberrypi.local</code> is the remote server,</li>
<li><code>8384</code> is the port number on the remote that you wish to
connect with,</li>
<li><code>127.0.0.1:8384</code> is the local machine and the port that
you want to redirect to, and</li>
<li><code>-N</code> is a flag telling <code>ssh</code> not to execute a
remote command.</li>
</ul>
<p>Tags: <a href='tag_cli.html'>cli</a>, <a href='tag_ssh.html'>ssh</a>, <a href='tag_motd.html'>motd</a></p>
<!-- text end -->
<h3><a class="ablack" href="using-tar-with-a-text-input-file23818.html">
Using Tar with a Text Input File
</a></h3>
<!-- bashblog_timestamp: #202307091649.03# -->
<div class="subtitle">July 09, 2023 &mdash; 
Gregg Szumowski
</div>
<!-- text begin -->
<p>If you have a lot of files in a directory and you only need to
<code>tar</code> a subset of them you can create a list of the files you
want in a text file and pass it to the <code>tar</code> command like
this:</p>
<blockquote>
<p><code>$ tar -cvf tarball.tar -T filelist.txt</code><br/></p>
</blockquote>
<p>or</p>
<blockquote>
<p><code>$ tar cvf tarball.tar $(cat filelist.txt)</code><br/></p>
</blockquote>
<p>Tags: <a href='tag_cli.html'>cli</a>, <a href='tag_tar.html'>tar</a>, <a href='tag_motd.html'>motd</a></p>
<!-- text end -->
<h3><a class="ablack" href="command-line-redirection28985.html">
Command Line Redirection
</a></h3>
<!-- bashblog_timestamp: #202307081025.10# -->
<div class="subtitle">July 08, 2023 &mdash; 
Gregg Szumowski
</div>
<!-- text begin -->
<p>Redirection is very significant in shell scripting. It provides you a
means to save the output of a command to a file or multiple files (one
for <code>stdout</code> and one for <code>stderr</code>).</p>
<p>Below is a table of simple redirections that are the most useful in
shell scripting. Here we are using the following naming conventions:</p>
<ul>
<li><code>stdout</code> – The output of the script/command</li>
<li><code>stderr</code> – The errors generated by the
script/command</li>
<li><code>outfile</code> – A target filename where you wish to store the
output</li>
<li><code>errfile</code> – A target filename where you wish to store the
errors</li>
</ul>
<blockquote>
<table>
<colgroup>
<col style="width: 29%" />
<col style="width: 70%" />
</colgroup>
<thead>
<tr class="header">
<th>Command</th>
<th>Description/Purpose</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>command 2&gt;errfile</td>
<td>Redirect stderr to errfile</td>
</tr>
<tr class="even">
<td>command &gt;outfile 2&gt;errfile</td>
<td>Redirect stderr to file named errfile and stdout to file named
outfile</td>
</tr>
<tr class="odd">
<td>command &amp;&gt; outfile</td>
<td>Redirect stderr and stdout to outfile</td>
</tr>
<tr class="even">
<td>command 2&gt;&amp;-</td>
<td>Just suppress error messages. No file created. No error message
displayed on screen</td>
</tr>
<tr class="odd">
<td>command 2&gt;&amp;1</td>
<td>Redirect error messages to standard output. Useful in shell script
when you need to forcefully display error messages on screen</td>
</tr>
</tbody>
</table>
</blockquote>
<p>Tags: <a href='tag_cli.html'>cli</a>, <a href='tag_bash.html'>bash</a>, <a href='tag_scripting.html'>scripting</a>, <a href='tag_redirection.html'>redirection</a>, <a href='tag_motd.html'>motd</a></p>
<!-- text end -->
<h3><a class="ablack" href="backup-files-with-specific-file-extension29561.html">
Backup Files with Specific File Extension
</a></h3>
<!-- bashblog_timestamp: #202307071814.55# -->
<div class="subtitle">July 07, 2023 &mdash; 
Gregg Szumowski
</div>
<!-- text begin -->
<p>Here is how you can use <code>rsync</code> to backup only the
<em>.ogg</em> files in the <em>Music</em> directory to the <em>OGG</em>
directory:</p>
<blockquote>
<p><code>$ rsync -a --prune-empty-dirs --include='*/' --include='*.ogg' --exclude='*' Music/ OGG/</code><br/></p>
</blockquote>
<p>Tags: <a href='tag_cli.html'>cli</a>, <a href='tag_rsync.html'>rsync</a>, <a href='tag_backups.html'>backups</a>, <a href='tag_motd.html'>motd</a></p>
<!-- text end -->
<h3><a class="ablack" href="some-sed-tips27116.html">
Some sed Tips
</a></h3>
<!-- bashblog_timestamp: #202307062052.03# -->
<div class="subtitle">July 06, 2023 &mdash; 
Gregg Szumowski
</div>
<!-- text begin -->
<p>Put an * between the number 5 and 6</p>
<blockquote>
<p><code>$ echo '12345678901234567890'| sed  -e 's/^.\{5\}/&amp;*/'</code><br/>
<code>12345*678901234567890</code><br/></p>
</blockquote>
<p>Put a comma between each number</p>
<blockquote>
<p><code>$ echo "1234567890" |sed  -e 's/./&amp;,/g' -e 's/,$//'</code><br/>
<code>1,2,3,4,5,6,7,8,9,0</code><br/></p>
</blockquote>
<p>Put comma after every 2, if not even then last number exist by
itself</p>
<blockquote>
<p><code>$ echo "1234567890" |sed  -e 's/../&amp;,/g' -e 's/,$//'</code><br/>
<code>12,34,56,78,90</code><br/></p>
</blockquote>
<p>Double space the data in file data1</p>
<blockquote>
<p><code>$ sed G data1</code><br/></p>
</blockquote>
<p>Triple space the data file file data1</p>
<blockquote>
<p><code>$ sed  'G;G' data1</code><br/></p>
</blockquote>
<p>Single space a double spaced file</p>
<blockquote>
<p><code>$ sed 'n;d' data1</code><br/></p>
</blockquote>
<p>DOS to Linux conversion</p>
<blockquote>
<p><code>$ sed 's/.$//' DOSfile &gt;Linuxfile</code><br/></p>
</blockquote>
<p>Truncate everything after a substring (‘with’ in this case):</p>
<blockquote>
<p><code>$ cat file.txt</code><br/>
<code>Brown Potatoes with Cheese</code><br/>
<code>Yellow Potatoes with Sugar and Cheese</code><br/>
<code>$ sed -i.bak 's/with.*//g' file.txt</code><br/>
<code>$ cat file.txt</code><br/> <code>Brown Potatoes</code><br/>
<code>Yellow Potatoes</code><br/></p>
</blockquote>
<p>Tags: <a href='tag_cli.html'>cli</a>, <a href='tag_sed.html'>sed</a>, <a href='tag_motd.html'>motd</a></p>
<!-- text end -->
<div id="all_posts"><a href="all_posts.html">View more posts</a> &mdash; <a href="all_tags.html">All tags</a> &mdash; <a href="feed.rss">Subscribe</a></div>
</div>
<div id="footer">CC by-nc-nd <a href="http://twitter.com/gszumo">Gregg Szumowski</a> &mdash; <a href="mailto:gszumo[at]gmail[dot]com">gszumo[at]gmail[dot]com</a> &mdash; <a rel="me" href="https://mastodon.sdf.org/@gszumo">Mastodon</a><br/>
NOTE: All tips provided are USE AT YOUR OWN RISK. It is suggested that you read and test each tip in a non-volitile environment before placing into production.<br/>
Generated with <a href="https://github.com/cfenollosa/bashblog">bashblog</a>, a single bash script to easily create blogs like this one</div>
</div></div>
</body></html>
