<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head>
<meta http-equiv="Content-type" content="text/html;charset=UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<link rel="stylesheet" href="main.css" type="text/css" />
<link rel="stylesheet" href="blog.css" type="text/css" />
<link rel="alternate" type="application/rss+xml" title="Subscribe to this page..." href="feed.rss" />
<title>Gregg's MOTD &mdash; Posts tagged "cli"</title>
</head><body>
<div id="divbodyholder">
<div class="headerholder"><div class="header">
<div id="title">
<h1 class="nomargin"><a class="ablack" href="http://www.szumowski.org/index.html">Gregg's MOTD</a></h1>
<div id="description">Tips & Tricks that I've Encountered Over the Years...</div>
</div></div></div>
<div id="divbody"><div class="content">
<h3><a class="ablack" href="python-initializing-a-new-project-using-venv.html">
Python: Initializing a New Project using venv
</a></h3>
<!-- bashblog_timestamp: #202307012007.47# -->
<div class="subtitle">July 01, 2023 &mdash; 
Gregg Szumowski
</div>
<!-- text begin -->
<p>Start out by creating a new directory or cloning a repository (which
creates a directory) and <em>cd</em> into it:</p>
<blockquote>
<p><code>$ git clone https://gitlab.com/username/proj-name</code><br/>
<code>$ cd proj-name/</code><br/></p>
</blockquote>
<p>Initialize the virtual environment:</p>
<blockquote>
<p><code>$ python3 -m venv venv</code><br/>
<code>$ source venv/bin/activate</code><br/></p>
</blockquote>
<p>Install whatever dependencies you need:</p>
<blockquote>
<p><code>$ pip install package1 package2</code><br/></p>
</blockquote>
<p>Then develop and/or run your program:</p>
<blockquote>
<p><code>$ python data_model.py</code><br/>
<code>$ python app.py</code><br/>
<code>$ sqlite3 hpr.sqlite "select count(*) from users"</code><br/></p>
</blockquote>
<p>When you’re done working you can <em>deactivate</em> the environment
by typing:</p>
<blockquote>
<p><code>$ deactivate</code><br/></p>
</blockquote>
<p>Tags: <a href='tag_cli.html'>cli</a>, <a href='tag_python.html'>python</a>, <a href='tag_venv.html'>venv</a>, <a href='tag_virtual.html'>virtual</a>, <a href='tag_environment.html'>environment</a>, <a href='tag_motd.html'>motd</a></p>
<!-- text end -->
<h3><a class="ablack" href="printing-numbers-using-thousand-separators.html">
Printing Numbers using Thousand Separators
</a></h3>
<!-- bashblog_timestamp: #202306301905.13# -->
<div class="subtitle">June 30, 2023 &mdash; 
Gregg Szumowski
</div>
<!-- text begin -->
<p>You can use a pipe to <code>awk</code> to output numbers with
thousands separators (commas). For Example, here’s how you can total the
5th column of the <code>ls -l</code> command and print it with thousands
separators:</p>
<blockquote>
<p><code>$ ls -l | awk '{total = total + $5}END{print total}' | LC_ALL=en_US.UTF-8 awk '{printf("%'"'"'d\n", $0) }'</code><br/>
<code>21,387</code><br/></p>
</blockquote>
<p>This can be adapted to other commands as necessary.</p>
<p>Tags: <a href='tag_cli.html'>cli</a>, <a href='tag_bash.html'>bash</a>, <a href='tag_awk.html'>awk</a>, <a href='tag_motd.html'>motd</a></p>
<!-- text end -->
<h3><a class="ablack" href="ubuntu-disable-cloud-init-on-startup9393.html">
Ubuntu: Disable cloud-init on Startup
</a></h3>
<!-- bashblog_timestamp: #202306282003.08# -->
<div class="subtitle">June 28, 2023 &mdash; 
Gregg Szumowski
</div>
<!-- text begin -->
<p>In systems that use <code>systemd</code> and have a current (17.0+)
version of <code>cloud-init</code>, upstream documentation describes the
process for disabling <code>cloud-init</code> with either of the
following:</p>
<blockquote>
<p><code>* touch /etc/cloud/cloud-init.disabled</code><br/></p>
</blockquote>
<p>or,</p>
<blockquote>
<p><code>* add cloud-init=disabled to the kernel command line.</code><br/></p>
</blockquote>
<p>Tags: <a href='tag_cli.html'>cli</a>, <a href='tag_ubuntu.html'>ubuntu</a>, <a href='tag_cloud-init.html'>cloud-init</a>, <a href='tag_motd.html'>motd</a></p>
<!-- text end -->
<h3><a class="ablack" href="red-hat-subscripion-manager---registering.html">
Red Hat Subscripion Manager - Registering
</a></h3>
<!-- bashblog_timestamp: #202306271801.40# -->
<div class="subtitle">June 27, 2023 &mdash; 
Gregg Szumowski
</div>
<!-- text begin -->
<p>Registering your RHEL instance with Red Hat is straightforward
assuming that you already have an account:</p>
<blockquote>
<p><code># subscription-manager register --username &lt;your-rh-user&gt; --password &lt;password&gt;</code><br/></p>
</blockquote>
<p>List the available repos or just go with a default:</p>
<blockquote>
<p><code># subscription-manager list --available</code><br/>
<code># subscription-manager attach --auto</code><br/></p>
</blockquote>
<p>Then you can do your update:</p>
<blockquote>
<p><code># yum update</code><br/></p>
</blockquote>
<p>Tags: <a href='tag_cli.html'>cli</a>, <a href='tag_rhel.html'>rhel</a>, <a href='tag_motd.html'>motd</a></p>
<!-- text end -->
<h3><a class="ablack" href="rhel-qcow-image-password23397.html">
RHEL QCOW Image Password
</a></h3>
<!-- bashblog_timestamp: #202306261907.09# -->
<div class="subtitle">June 26, 2023 &mdash; 
Gregg Szumowski
</div>
<!-- text begin -->
<p>Did you know that although you can install RHEL from an
<code>ISO</code>, you can also download a <code>QCOW2</code> image from
Red Hat. However, when you try to start it up under
<code>virt-manager</code> you’ll see that it boots to a
<code>root</code> prompt and you don’t know what the password is. This
can be fixed by running the following from the host’s terminal:</p>
<blockquote>
<p><code># virt-customize -a &lt;qcow2-image-file-name&gt; --root-password password:&lt;password&gt;</code><br/></p>
</blockquote>
<p>Tags: <a href='tag_cli.html'>cli</a>, <a href='tag_rhel.html'>rhel</a>, <a href='tag_qcow.html'>qcow</a>, <a href='tag_motd.html'>motd</a></p>
<!-- text end -->
<h3><a class="ablack" href="find-system-hogs-and-child-processes30247.html">
Find System Hogs and Child Processes
</a></h3>
<!-- bashblog_timestamp: #202306251120.06# -->
<div class="subtitle">June 25, 2023 &mdash; 
Gregg Szumowski
</div>
<!-- text begin -->
<p>There are a lot of tools out there that can help you to do this that
are both GUI or command line-based but sometimes you’re on a production
server that may have limited tools and sometimes the simplest tools are
best in cases like this.</p>
<p>List the processes that are not owned by you that are using a lot of
CPU:</p>
<blockquote>
<p><code>$ ps aux --sort=-%cpu | grep -m 8 -v</code>whoami<code></code><br/></p>
</blockquote>
<p>or by memory:</p>
<blockquote>
<p><code>$ ps aux --sort=-%mem | grep -m 8 -v</code>whoami<code></code><br/></p>
</blockquote>
<p>or by longest running process:</p>
<blockquote>
<p><code>$ ps aux --sort=-time | grep -m 8 -v</code>whoami<code></code><br/></p>
</blockquote>
<p>List processes by a specific user:</p>
<blockquote>
<p><code>$ ps -U gszumo</code><br/></p>
</blockquote>
<p>or multiple users:</p>
<blockquote>
<p><code>$ ps -U gszumo -U katy</code><br/></p>
</blockquote>
<p>You can see child proceses:</p>
<blockquote>
<p><code>$ ps -eo pid,args --forest</code><br/></p>
</blockquote>
<p>or children of a specific process:</p>
<blockquote>
<p><code>$ ps -f --ppid 4775</code><br/></p>
</blockquote>
<p>I don’t remember where I found these tips but they have come in handy
on many occasions and I am documenting them here hoping that readers
(whatever few there are) will also benefit from them.</p>
<p>Tags: <a href='tag_cli.html'>cli</a>, <a href='tag_ps.html'>ps</a>, <a href='tag_processes.html'>processes</a>, <a href='tag_motd.html'>motd</a></p>
<!-- text end -->
<h3><a class="ablack" href="how-to-list-installed-packages-in-fedora-rhel-centos.html">
How to List Installed Packages in Fedora, RHEL, CentOS
</a></h3>
<!-- bashblog_timestamp: #202306241747.43# -->
<div class="subtitle">June 24, 2023 &mdash; 
Gregg Szumowski
</div>
<!-- text begin -->
<p>Listing installed packages with YUM:</p>
<blockquote>
<p><code>$ sudo yum list installed</code><br/></p>
</blockquote>
<p>To display details about a package:</p>
<blockquote>
<p><code>$ yum info nginx</code><br/></p>
</blockquote>
<p>You can cat all installed packages to a file, copy the file to
another machine and duplicate the system:</p>
<blockquote>
<p><code>$ sudo yum list installed &gt; installed-packages.txt</code><br/>
<code>$ sudo yum -y install $(cat installed-packages.txt)</code><br/></p>
</blockquote>
<p>List installed packages with RPM:</p>
<blockquote>
<p><code>$ sudo rpm -qa</code><br/></p>
</blockquote>
<p>List them by installation date:</p>
<blockquote>
<p><code>$ sudo rpm -qa --last</code><br/></p>
</blockquote>
<p>Display information about a package:</p>
<blockquote>
<p><code>$ rpm -qi nginx</code><br/></p>
</blockquote>
<p>Tags: <a href='tag_cli.html'>cli</a>, <a href='tag_rpm.html'>rpm</a>, <a href='tag_yum.html'>yum</a>, <a href='tag_rhel.html'>rhel</a>, <a href='tag_fedora.html'>fedora</a>, <a href='tag_motd.html'>motd</a></p>
<!-- text end -->
<h3><a class="ablack" href="git-deleting-multiple-commits24780.html">
Git: Deleting Multiple Commits
</a></h3>
<!-- bashblog_timestamp: #202306231254.32# -->
<div class="subtitle">June 23, 2023 &mdash; 
Gregg Szumowski
</div>
<!-- text begin -->
<p>Let’s say that you want to delete the last 3 commits that you’ve
already pushed to the remote repository. In this example, you want
<code>566dab6</code> to be the new HEAD revision.</p>
<blockquote>
<p><code>$ git log --pretty=oneline --abbrev-commit</code><br/>
<code>57bc36b (HEAD -&gt; master, origin/master, origin/HEAD) 3nd set of bad entries on 6th commit</code><br/>
<code>dfb4bd3 2nd set of bad entries on 5th commit</code><br/>
<code>0fd1e16 First set of bad entries on 4th commit</code><br/>
<code>566dab6 Yet more good entries on third commit</code><br/>
<code>d50370a More good entries on second commit</code><br/>
<code>b5fbc6d Good entries on first commit</code><br/>
<code>2cad4c7 Initial commit</code><br/></p>
</blockquote>
<p>You can use <code>git reset</code>, <code>git revert</code>, or
<code>git checkout</code> to achieve this goal.</p>
<p><strong>Using reset:</strong></p>
<blockquote>
<p><code>$ git reset --hard HEAD~3</code><br/> <br/>
<code>$ git log --pretty=oneline --abbrev-commit</code><br/>
<code>566dab6 (HEAD -&gt; master) Yet more good entries on third commit</code><br/>
<code>d50370a More good entries on second commit</code><br/>
<code>b5fbc6d Good entries on first commit</code><br/>
<code>2cad4c7 Initial commit</code><br/></p>
</blockquote>
<p>Then you have to force push to the origin:</p>
<blockquote>
<p><code>$ git push --force</code><br/></p>
</blockquote>
<p><strong>Using revert:</strong></p>
<blockquote>
<p><code>$ git revert --no-commit 57bc36b</code><br/>
<code>$ git revert --no-commit dfb4bd3</code><br/>
<code>$ git revert --no-commit 0fd1e16</code><br/></p>
</blockquote>
<p>or do all 3 at once:</p>
<blockquote>
<p><code>$ git revert --no-commit HEAD~3..</code><br/></p>
</blockquote>
<p>Then do the commit:</p>
<blockquote>
<p><code>$ git commit -m "Fixed commits"</code><br/> <br/>
<code>$ git log --pretty=oneline --abbrev-commit</code><br/>
<code>0da0f42 (HEAD -&gt; master) Fixed commits</code><br/>
<code>57bc36b 3nd set of bad entries on 6th commit</code><br/>
<code>dfb4bd3 2nd set of bad entries on 5th commit</code><br/>
<code>0fd1e16 First set of bad entries on 4th commit</code><br/>
<code>566dab6 Yet more good entries on third commit</code><br/>
<code>d50370a More good entries on second commit</code><br/>
<code>b5fbc6d Good entries on first commit</code><br/>
<code>2cad4c7 Initial commit</code><br/></p>
</blockquote>
<p><strong>Using checkout:</strong></p>
<p>Checkout that revision over the top of local files</p>
<blockquote>
<p><code>$ git checkout -f 566dab6 -- .</code><br/>
<code>$ git commit -a</code><br/> <br/>
<code>$ git log --pretty=oneline --abbrev-commit</code><br/>
<code>0da0f42 (HEAD -&gt; master) Fixed commits</code><br/>
<code>57bc36b 3nd set of bad entries on 6th commit</code><br/>
<code>dfb4bd3 2nd set of bad entries on 5th commit</code><br/>
<code>0fd1e16 First set of bad entries on 4th commit</code><br/>
<code>566dab6 Yet more good entries on third commit</code><br/>
<code>d50370a More good entries on second commit</code><br/>
<code>b5fbc6d Good entries on first commit</code><br/>
<code>2cad4c7 Initial commit</code><br/></p>
</blockquote>
<p>Tags: <a href='tag_cli.html'>cli</a>, <a href='tag_git.html'>git</a>, <a href='tag_source-control.html'>source-control</a>, <a href='tag_motd.html'>motd</a></p>
<!-- text end -->
<h3><a class="ablack" href="deleting-blank-lines-using-grep16496.html">
Deleting Blank Lines Using Grep
</a></h3>
<!-- bashblog_timestamp: #202306201035.38# -->
<div class="subtitle">June 20, 2023 &mdash; 
Gregg Szumowski
</div>
<!-- text begin -->
<p>If you have a file (or a stream) that has blank lines you want to
remove, you can use this command:</p>
<blockquote>
<p><code>$ grep -v "^ *$" file-with-blanks.txt &gt; output-file.txt</code></p>
</blockquote>
<p>where <code>file-with-blanks.txt</code> is the input file and has
blank lines and <code>output-file.txt</code> will be the output file
without the blank lines.</p>
<p>You have to keep the <code>space</code> between the <code>^</code>
and the <code>*$</code> otherwise blank lines which include spaces will
not be removed.</p>
<p>Tags: <a href='tag_cli.html'>cli</a>, <a href='tag_grep.html'>grep</a>, <a href='tag_motd.html'>motd</a></p>
<!-- text end -->
<h3><a class="ablack" href="convert-webm-to-mp429535.html">
Convert webm to mp4
</a></h3>
<!-- bashblog_timestamp: #202306191112.17# -->
<div class="subtitle">June 19, 2023 &mdash; 
Gregg Szumowski
</div>
<!-- text begin -->
<p>You can use ffmpeg to convert webm to mp4 on the command line very
easily:</p>
<blockquote>
<p><code>$ ffmpeg -i file.webm -c copy file.mp4</code><br/></p>
</blockquote>
<p>This will stream copy (re-mux) and avoid re-encoding.</p>
<p>Tags: <a href='tag_cli.html'>cli</a>, <a href='tag_ffmpeg.html'>ffmpeg</a>, <a href='tag_webm.html'>webm</a>, <a href='tag_mp4.html'>mp4</a>, <a href='tag_convert.html'>convert</a>, <a href='tag_video.html'>video</a>, <a href='tag_motd.html'>motd</a></p>
<!-- text end -->
<h3><a class="ablack" href="parsing-bitwarden-cli4247.html">
Parsing Bitwarden CLI
</a></h3>
<!-- bashblog_timestamp: #202306151840.52# -->
<div class="subtitle">June 15, 2023 &mdash; 
Gregg Szumowski
</div>
<!-- text begin -->
<p>If you use the excellent Bitwarden app for you password storage you
may not be aware that they also have a command line version on Linux. It
outputs data using the JSON format. You can install the <code>jq</code>
JSON parser and pipe the output of the CLI’s query to it in order to
extract the username and password for a specific site in your
search:</p>
<blockquote>
<p><code>$ bw list items --search accounts.google.com | jq '.[] | .login.uris[].uri,.login.username,.login.password'</code><br/>
<code>"https://accounts.google.com"</code><br/>
<code>"john.doe@gmail.com"</code><br/>
<code>"** password1 **"</code><br/>
<code>"https://accounts.google.com"</code><br/>
<code>"jdoe@gmail.com"</code><br/>
<code>"** password2 **"</code><br/></p>
</blockquote>
<p>Tags: <a href='tag_cli.html'>cli</a>, <a href='tag_bitwarden.html'>bitwarden</a>, <a href='tag_json.html'>json</a>, <a href='tag_password-managers.html'>password-managers</a>, <a href='tag_motd.html'>motd</a></p>
<!-- text end -->
<h3><a class="ablack" href="export-virtualbox-vdi-using-cli1819.html">
Export VirtualBox VDI using CLI
</a></h3>
<!-- bashblog_timestamp: #202306141630.28# -->
<div class="subtitle">June 14, 2023 &mdash; 
Gregg Szumowski
</div>
<!-- text begin -->
<p>Sometimes you may want to move a virtual machine in VirtualBox from
one server to another. Once way of doing that is to export it from the
command line.</p>
<ol type="1">
<li>Locate the virtual machine that you want to export (I’ll use the
name UbuntuServer for the one to be exported and name the new one
UbuntuServerNew), and then</li>
<li>Run the export command as follows:</li>
</ol>
<blockquote>
<p><code>$ vboxmanage export UbuntuServer -o UbuntuServerNew.ova</code></p>
</blockquote>
<p>Tags: <a href='tag_cli.html'>cli</a>, <a href='tag_virtualization.html'>virtualization</a>, <a href='tag_virtualbox.html'>virtualbox</a>, <a href='tag_motd.html'>motd</a></p>
<!-- text end -->
<h3><a class="ablack" href="bulk-change-of-file-extensions-in-directory32717.html">
Bulk Change of File Extensions in Directory
</a></h3>
<!-- bashblog_timestamp: #202306111125.59# -->
<div class="subtitle">June 11, 2023 &mdash; 
Gregg Szumowski
</div>
<!-- text begin -->
<p>If you have a directory of files where you want to change all of the
file extensions you may find this code snippet useful to rename
them:</p>
<blockquote>
<p><code>for i in *.tmp</code><br/> <code>do</code><br/>
<code>mv ${i} ${i%.*}.txt</code><br/> <code>done</code><br/></p>
</blockquote>
<p>Tags: <a href='tag_cli.html'>cli</a>, <a href='tag_bash.html'>bash</a>, <a href='tag_rename.html'>rename</a>, <a href='tag_motd.html'>motd</a></p>
<!-- text end -->
<h3><a class="ablack" href="rename-files-downloaded-using-youtube-dl10234.html">
Rename Files Downloaded Using youtube-dl
</a></h3>
<!-- bashblog_timestamp: #202306101630.00# -->
<div class="subtitle">June 10, 2023 &mdash; 
Gregg Szumowski
</div>
<!-- text begin -->
<p>If you have used <code>youtube-dl</code> to download content from
YouTube then you know that the file names can get to be rather long. In
addition to the video’s title there is a dash followed by what appears
to be a random sequence of characters just before the file extension. If
you find this to be annoying then here is a code snippet that you can
use to remove it.</p>
<p>This will remove the last field separated by a ‘-’ and replace it
with the file extension of your choice, .mp4 is used in this
example:</p>
<blockquote>
<p><code>#!/bin/bash</code><br/> <code>for i in *.mp4</code><br/>
<code>do</code><br/>
<code># Remove everything from the last hyphen to the end</code><br/>
<code>file="${i%-*}"</code><br/>
<code># Rename the file and remove the space between 'file'</code><br/>
<code># and the file extension on the fly</code><br/>
<code>mv "${i}" "${file%%*( )}.mp4"</code><br/>
<code>done</code><br/></p>
</blockquote>
<p>Tags: <a href='tag_cli.html'>cli</a>, <a href='tag_youtube.html'>youtube</a>, <a href='tag_renaming.html'>renaming</a>, <a href='tag_motd.html'>motd</a></p>
<!-- text end -->
<h3><a class="ablack" href="sending-email-from-the-command-line-with-mutt27176.html">
Sending Email from the Command Line with mutt
</a></h3>
<!-- bashblog_timestamp: #202306071052.23# -->
<div class="subtitle">June 07, 2023 &mdash; 
Gregg Szumowski
</div>
<!-- text begin -->
<p>If you prefer using <code>mutt</code> as your command line email
tool, then here are a couple of examples of using <code>mutt</code> to
send emails which can be automated quite easily to use in scripts.</p>
<p>Sending a file attachment (-a) and an empty message body:</p>
<p><code>$ mutt  -s "System Logs" -a /var/log/somelog.log -- username@example.com &lt; /dev/null</code></p>
<p>Sending a message body using redirection:</p>
<p><code>$ mutt -s "Email Subject" username@example.com &lt; email.html</code></p>
<p>Sending a file attachment along with a message body:</p>
<p><code>$ echo $message | mutt -s "Email Subject" -a attachment.txt -- username@example.com</code></p>
<p>Tags: <a href='tag_cli.html'>cli</a>, <a href='tag_mutt.html'>mutt</a>, <a href='tag_mail.html'>mail</a>, <a href='tag_motd.html'>motd</a></p>
<!-- text end -->
<h3><a class="ablack" href="sending-email-from-the-command-line-with-curl.html">
Sending Email from the Command Line with cURL
</a></h3>
<!-- bashblog_timestamp: #202306061746.07# -->
<div class="subtitle">June 06, 2023 &mdash; 
Gregg Szumowski
</div>
<!-- text begin -->
<p>Let’s assume that you had a RFC 5822 formatted file named
<code>mail.txt</code> as follows:</p>
<pre><code>From: Some Sender &lt;some.sender@gmail.com&gt;
To: Some Recipient &lt;some.recipient@example.com&gt;
Subject: Saying Hello
Date: Tue, 6 Jun 2023 04:15:06 -0100
Message-ID: &lt;1234@local.machine.example&gt;

This is a message just to say hello.
So, &quot;Hello&quot;.</code></pre>
<p>You can forward this to a email recipient using Google’s SMTP with
the following <code>curl</code> command provided you have a Google app
password:</p>
<pre><code>$ curl --url &#39;smtps://smtp.gmail.com:465&#39; --ssl-reqd \
 --mail-from &#39;some.sender@gmail.com&#39; \ 
 --mail-rcpt &#39;some.recipient@example.com&#39; \
 --upload-file mail.txt \
 --user &#39;some.sender@gmail.com:your-gmail-app-password&#39;</code></pre>
<p>Output should be something like this:</p>
<pre><code>  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current
                                 Dload  Upload   Total   Spent    Left  Speed
100    12    0     0  100    12      0     10  0:00:01  0:00:01 --:--:--    10
$</code></pre>
<p>Tags: <a href='tag_cli.html'>cli</a>, <a href='tag_curl.html'>curl</a>, <a href='tag_mail.html'>mail</a>, <a href='tag_motd.html'>motd</a></p>
<!-- text end -->
<h3><a class="ablack" href="transfering-files-using-netcat20089.html">
Transfering Files Using netcat
</a></h3>
<!-- bashblog_timestamp: #202306052136.39# -->
<div class="subtitle">June 05, 2023 &mdash; 
Gregg Szumowski
</div>
<!-- text begin -->
<p>You can use <code>netcat</code> to transfer a file from one machine
to another machine. On the receiving machine enter the following
command:</p>
<p><code>$ netcat -l 12345 &gt; file.txt</code> or</p>
<p><code>$ netcat -l -p 12345 &gt; file.pdf</code></p>
<p>Then, on the sending machine use this command:</p>
<p><code>$ netcat $MY_IP_ADDRESS 12345 &lt; file.txt</code></p>
<p>Tags: <a href='tag_cli.html'>cli</a>, <a href='tag_netcat.html'>netcat</a>, <a href='tag_nc.html'>nc</a>, <a href='tag_motd.html'>motd</a></p>
<!-- text end -->
<h3><a class="ablack" href="how-to-use-dnf-history21154.html">
How to Use DNF History
</a></h3>
<!-- bashblog_timestamp: #202306031836.30# -->
<div class="subtitle">June 03, 2023 &mdash; 
Gregg Szumowski
</div>
<!-- text begin -->
<p>If you are using a Red Hat/Fedora-based distro, here are some tips on
how to use the <code>dnf</code> tool to query your install history:</p>
<p>Retrieve a list of manually installed packages:</p>
<p><code>$ dnf history userinstalled</code></p>
<p>Retrieve a list of all transactions:</p>
<p><code>$ dnf history list all</code></p>
<p>List the changes in a particular transaction:</p>
<p><code>$ history list &lt;num&gt;</code></p>
<p>Undo/rollback a transaction:</p>
<p><code>$ dnf history undo &lt;num&gt;</code></p>
<p>Tags: <a href='tag_cli.html'>cli</a>, <a href='tag_packaging.html'>packaging</a>, <a href='tag_dnf.html'>dnf</a>, <a href='tag_motd.html'>motd</a></p>
<!-- text end -->
<h3><a class="ablack" href="windows-terminal-keyboard-shortcuts30027.html">
Windows Terminal Keyboard Shortcuts
</a></h3>
<!-- bashblog_timestamp: #202306021847.19# -->
<div class="subtitle">June 02, 2023 &mdash; 
Gregg Szumowski
</div>
<!-- text begin -->
<p>I have to use Windows where I work but I use the terminal as often as
possible. Microsoft’s Windows Terminal application makes that experience
tolerable. You can even think that you’re using <code>tmux</code> at
times…well, not really, but you get the idea.</p>
<p>Here are some of the keyboard shortcuts that I use:</p>
<p><strong>Split current terminal window</strong></p>
<p><code>Alt Shift</code> - split pane horizontal</p>
<p><code>Alt Shift</code> - split pane vertical</p>
<p><strong>Jump to other console</strong></p>
<p><code>Alt &lt;arrow key&gt;</code></p>
<p><strong>Resize current terminal window</strong></p>
<p><code>Alt Shift &lt;arrow key&gt;</code></p>
<p><strong>Close terminal window</strong></p>
<p><code>Ctrl Shift W</code></p>
<p><strong>Others that I don’t use as much</strong></p>
<p><code>Ctrl + Shift + Number</code>: Open new profiles/tabs. Use this
shortcut to open a new profile or tab in Windows Terminal. Each number
represents a specific profile in the Terminal. Profiles are numbered in
the top-down form in the profile selection dropdown menu on the title
bar. For example, if the PowerShell profile is in the second position,
you should press the “Ctrl + Shift + 2” to open it.</p>
<p><code>Ctrl + Alt + Number</code>: Switch to a specific tab. Use this
shortcut to switch between tabs. Tabs are numbered from left to right
and start with “1.” For example, if you want to switch to the third tab,
press “Ctrl + Alt + 3.”</p>
<p><code>Ctrl + Shift + Space</code>: Opens profile selection dropdown
menu. You can then use the up/down arrow keys to select and open the
profile.</p>
<p><code>Ctrl + Shift + T</code>: Opens a new tab with the default
profile.</p>
<p><code>Ctrl + Shift + N</code>: Opens a new Windows Terminal
instance.</p>
<p><code>Ctrl + Shift + D</code>: This shortcut will duplicate or open
another instance of the current tab. However, it will not copy the
content of the original tab.</p>
<p><code>Ctrl + C</code>: Copy selected text. Select the text in the
Terminal and press the shortcut to copy it to the clipboard. Once
copied, you can paste it anywhere you want.</p>
<p><code>Ctrl + V</code>: Paste clipboard content. Pressing this
shortcut will paste the clipboard contents into the Terminal. Keep in
mind that only compatible content, like text, will be pasted. If you try
to paste incompatible content, like an image, the result will not be as
expected or intended.</p>
<p><code>Ctrl + Shift + W</code>: Close the current tab (not the entire
application).</p>
<p><code>Alt + F4</code>: Close the Windows Terminal window. If there
are multiple tabs, you might see a warning prompt. In that case, click
“Close all” to continue.</p>
<p><code>Ctrl + Shift + F</code>: Opens the “Find” function. It can be
used to find instances of a text or sentence in a terminal tab. This
functionality is similar to what you find in a browser or other
applications like Notepad, Word, etc.</p>
<p><code>Ctrl + Numpad Add/Minus</code>: Increase or decrease the text
size in the Windows Terminal tab.</p>
<p><code>Ctrl + 0</code>: Reset the font or text size its default
(100%).</p>
<p><code>Ctrl + Shift + Up/Down arrow</code>: Scroll up or down in the
Windows Terminal.</p>
<p><code>Ctrl + Shift + PageUp/PageDown</code>: Move to top or bottom in
the Windows Terminal.</p>
<p><code>Alt + Shift + Minus/Plus</code>: Split current pane
horizontally or vertically.</p>
<p><code>Ctrl + Shift + P</code>: Toggle command palette. It can be used
to select and execute a command or action from the available list.</p>
<p><code>Ctrl + Shift + ,</code>: This shortcut opens the Settings tab
in the Windows Terminal.</p>
<p><code>F11</code>: Toggle fullscreen.</p>
<p>Tags: <a href='tag_cli.html'>cli</a>, <a href='tag_windows.html'>windows</a>, <a href='tag_terminal.html'>terminal</a>, <a href='tag_shortcuts.html'>shortcuts</a>, <a href='tag_motd.html'>motd</a></p>
<!-- text end -->
<h3><a class="ablack" href="installing-foliate-ebook-reader-on-slackware-1517738.html">
Installing Foliate Ebook Reader on Slackware 15
</a></h3>
<!-- bashblog_timestamp: #202305301833.17# -->
<div class="subtitle">May 30, 2023 &mdash; 
Gregg Szumowski
</div>
<!-- text begin -->

<p>I don't know about you, but I love reading ebooks and I've used Foliate before on other distributions but can't find it for my OS of choice, Slackware. So, here's how to install it from source:</p>

<ol>
<li>Download the foliate software tarball from <a href="https://github.com/johnfactotum/foliate/releases">here</a></li>
<li>Install appstream-glib (which provides dependency appstream-util) using sboinstall</li>
<li>Install webkit2gtk (which provides dependency WebKit2) using sboinstall</li>
<li>Build foliate. Instructions are on the GitHub <a href="https://github.com/johnfactotum/foliate">page</a> or just extract the tarball, cd into the directory and then execute the following on the command line:</li>
</ol>

<p><code>$ tar zxvf foliate-2.6.4.tar.gz </code><br/>
<code>$ cd foliate-2.6.4</code><br/>
<code>$ meson build --prefix=/usr</code><br/>
<code>$ ninja -c build</code><br/>
<code>$ ninja -C build</code><br/>
<code>$ su -c "ninja -C build install"</code><br/></p>

<p>Tags: <a href='tag_cli.html'>cli</a>, <a href='tag_ebooks.html'>ebooks</a>, <a href='tag_slackware.html'>slackware</a>, <a href='tag_motd.html'>motd</a></p>
<!-- text end -->
<h3><a class="ablack" href="archive-only-files-in-a-directory23013.html">
Archive Only Files In a Directory
</a></h3>
<!-- bashblog_timestamp: #202305292036.09# -->
<div class="subtitle">May 29, 2023 &mdash; 
Gregg Szumowski
</div>
<!-- text begin -->

<p>If you want to create a tar archive of only the files of a directory and exclude any subdirectories you can use the <code>ls -la</code> command and pipe the output to <code>awk</code>. However you need to remove the first 8 fields from the output and leave all of the remaining parts of the line in case there are spaces in the filename. One quick and dirty way of doing that is to set each of the 8 fields to a blank and then use <code>sed</code> to trim the leading spaces. You can optionally add quotation marks around the filename in your output too.</p>

<p><code>
$ ls -al | awk '$0!~/^d/ {$1=$2=$3=$4=$5=$6=$7=$8=""; printf("%s\"\n", $0)}' | sed 's/^[[:space:]]*/"/' | xargs tar cvf archive-name.tar
</code></p>

<p>Tags: <a href='tag_cli.html'>cli</a>, <a href='tag_tar.html'>tar</a>, <a href='tag_awk.html'>awk</a>, <a href='tag_xargs.html'>xargs</a>, <a href='tag_sed.html'>sed</a>, <a href='tag_motd.html'>motd</a></p>
<!-- text end -->
<h3><a class="ablack" href="edit-a-remote-file-using-vim.html">
Edit a Remote File Using Vim
</a></h3>
<!-- bashblog_timestamp: #202305281554.48# -->
<div class="subtitle">May 28, 2023 &mdash; 
Gregg Szumowski
</div>
<!-- text begin -->

<p>To edit a file remotely using the vim editor, just do the following in a terminal window:</p>

<p><code>
$ scp://username@IP-address//path/to/file.txt
</code></p>

<p><br>The user must have access to the file being edited.<br></p>

<p>Tags: <a href='tag_cli.html'>cli</a>, <a href='tag_vim.html'>vim</a>, <a href='tag_scp.html'>scp</a>, <a href='tag_motd.html'>motd</a></p>
<!-- text end -->
<h3><a class="ablack" href="echo-file-until-a-blank-line-is-reached.html">
Echo File Until a Blank Line Is Reached
</a></h3>
<!-- bashblog_timestamp: #202305272122.53# -->
<div class="subtitle">May 27, 2023 &mdash; 
Gregg Szumowski
</div>
<!-- text begin -->

<p>You can use the <code>awk</code> program to search and print lines in a file. If you wanted to print a file until the first blank line is reached you can use the  following command to do that:</p>

<p><code>
awk '$0 ~ /^$/ {exit;} {print $0;}' somefile.txt
</code></p>

<p>Tags: <a href='tag_awk.html'>awk</a>, <a href='tag_cli.html'>cli</a>, <a href='tag_motd.html'>motd</a></p>
<!-- text end -->
<h3><a class="ablack" href="bash-environment-variables11985.html">
Bash Environment Variables
</a></h3>
<!-- bashblog_timestamp: #202305242059.35# -->
<div class="subtitle">May 24, 2023 &mdash; 
Gregg Szumowski
</div>
<!-- text begin -->

<p>Here are some bash environment variables that are useful to know when you're using the command prompt:</p>

<p><code> $0</code> - name of shell or shell script <br/>
<code> $1, $2, $3, ...</code> - positional parameters to script <br/>
<code> $#</code> - count of positional parameters <br/>
<code> $?</code> - exit status of most recent foreground task <br/>
<code> $-</code> - current options that are set for the shell <br/>
<code> $$</code> - PID of the current shell (not subshell) <br/>
<code> $!</code> - the PID of the most recent background command <br/>
<code> $DESKTOP_SESSION</code> - path to the current display manager <br/>
<code> $EDITOR</code> - preferred text editor <br/>
<code> $LANG</code> - current language <br/>
<code> $PATH</code> - directory list to search for executables (programs) <br/>
<code> $PWD</code> - current working directory <br/>
<code> $SHELL</code> - current shell <br/>
<code> $USER</code> - current username <br/>
<code> $HOME</code> - current user's home directory <br/>
<code> $HOSTNAME</code> - current name of the host <br/>
<code> $TERM</code> - current terminal <br/></p>

<p>Tags: <a href='tag_cli.html'>cli</a>, <a href='tag_bash.html'>bash</a>, <a href='tag_motd.html'>motd</a></p>
<!-- text end -->
<h3><a class="ablack" href="bash-cli-keyboard-shortcuts21656.html">
Bash CLI Keyboard Shortcuts
</a></h3>
<!-- bashblog_timestamp: #202305231807.26# -->
<div class="subtitle">May 23, 2023 &mdash; 
Gregg Szumowski
</div>
<!-- text begin -->

<p>Here are some quick keyboard shortcuts you can use at the command prompt:</p>

<p><br/><code>ctrl-l</code> -- clear screen
<br/><code>ctrl-r</code> -- does a search in the previously given commands so that you don't have to repeat long command.
<br/><code>ctrl-u</code> -- clears the typing before the hotkey.
<br/><code>ctrl-a</code> -- takes you to the begining of the command you are currently typing.
<br/><code>ctrl-e</code> -- takes you to the end of the command you are currently typing in.
<br/><code>esc-b</code> -- takes you back by one word while typing a command.
<br/><code>ctrl-c</code> -- kills the current command or process.
<br/><code>ctrl-d</code> -- kills the shell.
<br/><code>ctrl-h</code> -- deletes one letter at a time from the command you are typing in.
<br/><code>ctrl-z</code> -- puts the currently running process in background, the process can be brought back to run state by using fg command.
<br/><code>esc-p</code> -- like ctrl-r lets you search through the previously given commands.
<br/><code>esc-.</code> -- gives the last command you typed.</p>

<p>Tags: <a href='tag_cli.html'>cli</a>, <a href='tag_motd.html'>motd</a></p>
<!-- text end -->
<h3><a class="ablack" href="how-to-find-all-of-the-shell-scripts-in-a-directory.html">
How To Find All of the Shell Scripts In a Directory
</a></h3>
<!-- bashblog_timestamp: #202305212020.15# -->
<div class="subtitle">May 21, 2023 &mdash; 
Gregg Szumowski
</div>
<!-- text begin -->

<p>This is a quick and dirty way which will list all of the files that are shell scripts:</p>

<p><code> for i in * </code><br/>
<code> do </code><br/>
<code>     type=$(file ${i}|awk -F, '{print $2}')</code><br/>
<code>     if [[ "${type}" = " ASCII text executable" ]]; then </code><br/>
<code>         echo "${i} is a shell script"</code><br/>
<code>     fi</code><br/>
<code> done</code><br/>
<br/></p>

<p>Tags: <a href='tag_cli.html'>cli</a>, <a href='tag_motd.html'>motd</a>, <a href='tag_awk.html'>awk</a></p>
<!-- text end -->
<h3><a class="ablack" href="how-to-use-github-tokens-on-the-command-line1357.html">
How To Use Github Tokens on the Command Line
</a></h3>
<!-- bashblog_timestamp: #202305122120.39# -->
<div class="subtitle">May 12, 2023 &mdash; 
Gregg Szumowski
</div>
<!-- text begin -->

<p>GitHub’s access policy requires you to use tokens instead of username/password to update your repositories. </p>

<p>To adapt your existing local / cloned repos to token based auth:
<br/><code>$ git remote remove origin</code>
<br/><code>$ git remote add origin https://[TOKEN]@github.com/[USER]/[REPO]</code>
<br/><code>$ git push</code>
<br/><br/>
Clone repos using token based authentication (non public repos)</code>
<br/><code>$ git clone https://[username]:[token]@github.com/[accountname]/[reponame]</code>
<br/></p>

<p>Tags: <a href='tag_github.html'>github</a>, <a href='tag_tokens.html'>tokens</a>, <a href='tag_motd.html'>motd</a>, <a href='tag_cli.html'>cli</a></p>
<!-- text end -->
<h3><a class="ablack" href="how-to-count-all-the-files-extension-recursively-in-linux.html">
How To Count All The Files Extension Recursively In Linux
</a></h3>
<!-- bashblog_timestamp: #202305092200.54# -->
<div class="subtitle">May 09, 2023 &mdash; 
Gregg Szumowski
</div>
<!-- text begin -->

<p>To count all the files by file extension recursively on the command line<br/><br/>
<code> $ find . -type f | sed -n 's/..*.//p' | sort | uniq -c </code><br/>
<code>     40 3g2</code><br/>
<code>      5 AVI</code><br/>
<code>     13 DS_Store</code><br/>
<code>     28 JPG</code><br/>
<code>     30 MOV</code><br/>
<code>    133 MP4</code><br/>
<code>     64 THM</code><br/>
<code>      1 docx</code><br/>
<code>     18 jpg</code><br/>
<code>      1 json</code><br/>
<code>      4 m3u</code><br/>
<code>     89 m4a</code><br/>
<code>      2 m4r</code><br/>
<code>    156 m4v</code><br/>
<code>     41 mkv</code><br/>
<code>    112 mov</code><br/>
<code>     38 mp3</code><br/>
<code>    587 mp4</code><br/>
<code>      1 nfo</code><br/>
<code>      2 osp</code><br/>
<code>     30 png</code><br/>
<code>      1 sh</code><br/>
<code>      4 srt</code><br/>
<code>      6 svg</code><br/>
<code>     10 torrent</code><br/>
<code>      6 txt</code><br/>
<code>      5 webm</code><br/>
<code>     10 zip</code><br/>
</code>
<br></p>

<p>Tags: <a href='tag_cli.html'>cli</a>, <a href='tag_motd.html'>motd</a>, <a href='tag_find.html'>find</a>, <a href='tag_sed.html'>sed</a>, <a href='tag_sort.html'>sort</a>, <a href='tag_uniq.html'>uniq</a></p>
<!-- text end -->
<h3><a class="ablack" href="untar-a-tarball-to-a-remote-directory5321.html">
Untar a Tarball to a Remote Directory
</a></h3>
<!-- bashblog_timestamp: #202305081844.08# -->
<div class="subtitle">May 08, 2023 &mdash; 
Gregg Szumowski
</div>
<!-- text begin -->

<p>Sometimes you may need to copy an entire directory structure to another system using the command line. Here is a quick way to do it using the tar command:</p>

<p><code> cat myfile.tgz | ssh user@host "tar xzf - -C /some/dir" </code><br></p>

<p>Tags: <a href='tag_cli.html'>cli</a>, <a href='tag_motd.html'>motd</a>, <a href='tag_tar.html'>tar</a></p>
<!-- text end -->
<h3><a class="ablack" href="getting-rid-of-m-line-endings-in-a-text-file20658.html">
Getting Rid of ^M Line Endings in a Text File
</a></h3>
<!-- bashblog_timestamp: #202305061337.12# -->
<div class="subtitle">May 06, 2023 &mdash; 
Gregg Szumowski
</div>
<!-- text begin -->

<p>If you have a text file that has funny looking ^M characters at the end of each line, in most cases, you have to get rid of them before they can be used. This is especially the case when you've copied or transferred a file from a Windows-based system to a *nix-based one. If these files are shell scripts meant to run on the *nix-based system they more often than not won't work. There are various solutions to this problem.</p>

<p>First, let's create two text files: one with ^M line endings and one without:</p>

<p><code> $ for line in 1 2 3 4 5; do echo "This is line ${line}^M" >>file1.txt; done </code><br>
<code> $ for line in 1 2 3 4 5; do echo "This is line ${line}" >>file2.txt; done </code><br></p>

<p>Now let's see what's different between these two text files:</p>

<p><code> $ ls -l </code><br>
<code> total 8 </code><br>
<code> -rw-rw-r--. 1 gszumo gszumo 80 Oct 29 17:43 file1.txt </code><br>
<code> -rw-rw-r--. 1 gszumo gszumo 75 Oct 29 17:44 file2.txt </code><br></p>

<p><code> $ file file1.txt </code><br>
<code> file1.txt: ASCII text, with CRLF line terminators </code><br></p>

<p><code> $ file file2.txt </code><br>
<code> file2.txt: ASCII text </code><br></p>

<p><code> $ diff file1.txt file2.txt </code><br>
<code> 1,5c1,5 </code><br>
<code> &lt; This is line 1 </code><br>
<code> &lt; This is line 2 </code><br>
<code> &lt; This is line 3 </code><br>
<code> &lt; This is line 4 </code><br>
<code> &lt; This is line 5 </code><br>
<code> --- </code><br>
<code> > This is line 1 </code><br>
<code> > This is line 2 </code><br>
<code> > This is line 3 </code><br>
<code> > This is line 4 </code><br>
<code> > This is line 5 </code><br>
<code> $ </code><br></p>

<p>What does this tell us?</p>

<ul>
<li>The ls command tells us the file sizes are different even though the visible text is the same.</li>
<li>The file command tells us that both files are ASCII text  but file1.txt has CRLF line terminators, and</li>
<li>The diff command tells us that each line is indeed showing us that it's different.</li>
</ul>

<p>So, how do we fix this?</p>

<p>My favorite solution is to use vi or vim interactively. There are 2 easy ways to get rid of the ^M from a single file using vim:</p>

<ol>
<li>Enter the command:
<br><code> :%s/^M//g </code><br>
on the vim command line then save the file, or</li>
<li>Enter the command:
<br><code> :fileformat=unix </code><br>
on the vim command line and save the file.</li>
</ol>

<p>However, if you have a whole directory or directory tree full of these kinds of files using vim on each one individually will become quite tedious. For this you need the scripting capability of the command line!</p>

<p>The 'tr' command is one quick way of getting rid of them using the Linux or macOS command line:</p>

<p><code> cat somefile | tr -d '^M' >outputfile </code><br></p>

<p>We can use this as a template in order to determine whether or not the file needs to be updated:</p>

<p><code> for i in * </code><br>
<code> do </code><br>
<code>   string=$(file ${i}) </code><br>
<code>   test "${string#*'CRLF'}" != "$string" &amp;&amp; echo "CRLF found in ${i}" </code><br>
<code> done </code><br></p>

<p>If the 'echo' part of this snippet only gets called when the first part of the test is true, so then we know that the file has '^M' line endings. We have to turn the second part of the test into a script that will massage the file to remove the line endings. Here's a bash snippet that will put the two together and do the job:</p>

<p><code> for i in * </code><br>
<code> do </code><br>
<code>   string=$(file ${i}) </code><br>
<code>   if [ "${string#*'CRLF'}" != "$string" ];then </code><br>
<code>     cp ${i} ${i}.bak </code><br>
<code>     cat ${i}.bak|tr -d '^M' >${i} </code><br>
<code>     rm ${i}.bak </code><br>
<code>   fi </code><br>
<code> done </code><br></p>

<p>This is a bare-bones piece of code which doesn't do any error checking, which should be added in the event that the user running this script doesn't have the necessary permissions to copy, write or remove files that match the test.</p>

<p>Remember, in order to create a '^M' character in the terminal hold down the CTRL key while  typing vm.</p>

<p>You can also use 'ex' to replace a string in a file using:</p>

<p><code> ex -s -c '%s/old-str/new-str/g|x' filename.txt </code><br></p>

<p>Alternately, we can use sed to do the same thing. At the command line you can replace any string in a file dynamically by entering:</p>

<p><code> sed -i 's/old-str/new-str/' filename.txt </code><br></p>

<p>So to remove the ^M charaters just do:</p>

<p><code> sed -i 's/^M//' filename.txt </code><br></p>

<p>to remove the ^M characters. You can use the same for/do/done loop structure as mentioned above to iterate over multiple files:</p>

<p><code> for i in *.txt </code><br>
<code> do </code><br>
<code>   sed -i 's/^M//' ${i} </code><br>
<code> done </code><br></p>

<p>'Nuff said.</p>

<p>Tags: <a href='tag_cli.html'>cli</a>, <a href='tag_motd.html'>motd</a></p>
<!-- text end -->
<h3><a class="ablack" href="removing-m-characters-from-multiple-files19102.html">
Removing ^M Characters From Multiple Files
</a></h3>
<!-- bashblog_timestamp: #202305052225.36# -->
<div class="subtitle">May 05, 2023 &mdash; 
Gregg Szumowski
</div>
<!-- text begin -->

<p>In my day job I find that I frequently need to remove those pesky '^M' line endings from text files that are transferred from one system to the other. Most of the time it is just one file that needs to be fixed so going into vi and typing</p>

<p><code> :%s/^M//g </code><br></p>

<p>solves the problem, but on occasion I might be confronted with performing this process on multiple files and sometimes recursively through many subdirectories. When that happens it becomes necessary to bring out the "big guns" and do:</p>

<p><code> $ for file in $(find /path/to/dir -type f); do </code><br>
<code>       tr -d '\r' <$file >temp.$$ &amp;&amp; mv temp.$$ $file </code><br>
<code>   done </code><br>
<code> $ </code><br></p>

<p>(BTW, to generate a ^M character using the PuTTY emulator is easy. Just press CTRL-^ followed by CTRL-M)</p>

<p>Of course, in Linux, UNIX and AIX shells there are many ways to skin a cat and this is just one of many possible solutions. This solution was found on <a href="https://dailyvim.blogspot.com">a Daily Vim Blogspot site</a> which has more very interesting tips &amp; tutorials.</p>

<p>Tags: <a href='tag_cli.html'>cli</a>, <a href='tag_motd.html'>motd</a></p>
<!-- text end -->
<h3><a class="ablack" href="get-the-hash-of-a-file-on-different-operating-systems17003.html">
Get the Hash of a File on Different Operating Systems
</a></h3>
<!-- bashblog_timestamp: #202305041829.20# -->
<div class="subtitle">May 04, 2023 &mdash; 
Gregg Szumowski
</div>
<!-- text begin -->

<p>Sometimes you just need to hash something. Here are some command lines to do just that.</p>

<p>Windows PowerShell:</p>

<p><code> Get-FileHash C:\path\to\file.iso -Algorithm [MD5|SHA1|SHA256|SHA384|SHA512|MACTripleDES|RIPEMD160] </code><br></p>

<p>(SHA256 is the default if the parameter is omitted) </p>

<p>Linux: </p>

<p><code> md5sum /path/to/file </code><br>
<code> sha1sum /path/to/file </code><br>
<code> sha256sum /path/to/file </code><br></p>

<p>macOS:</p>

<p><code> MD5: md5 /path/to/file </code><br>
<code> SHA1: shasum /path/to/file or shasum -a 1 /path/to/file </code><br>
<code> SHA-256: shasum -a 256 /path/to/file </code><br></p>

<p>Tags: <a href='tag_cli.html'>cli</a>, <a href='tag_motd.html'>motd</a></p>
<!-- text end -->
<h3><a class="ablack" href="copy-entire-directory-structure-using-tar3546.html">
Copy Entire Directory Structure Using Tar
</a></h3>
<!-- bashblog_timestamp: #202305031813.27# -->
<div class="subtitle">May 03, 2023 &mdash; 
Gregg Szumowski
</div>
<!-- text begin -->

<p>Sometimes you need to copy an entire directory structure to another location on the command line. Here is a quick way to do it using the tar command:</p>

<p><code> tar cf - * | ( cd /target; tar xfp -) </code><br></p>

<p>Tags: <a href='tag_cli.html'>cli</a>, <a href='tag_motd.html'>motd</a></p>
<!-- text end -->
<h3><a class="ablack" href="sort-directory-by-file-size1118.html">
Sort Directory by File Size
</a></h3>
<!-- bashblog_timestamp: #202305012215.27# -->
<div class="subtitle">May 01, 2023 &mdash; 
Gregg Szumowski
</div>
<!-- text begin -->

<p>To sort files in a directory and to list them by the biggest file first:<br>
<code>
$ du -a | sort -n -r | more
</code>
<br>Alternatively you can use:<br>
<code>
$ du -s * | sort -n -r | more
</code>
<br></p>

<p>Tags: <a href='tag_cli.html'>cli</a>, <a href='tag_motd.html'>motd</a></p>
<!-- text end -->
<h3><a class="ablack" href="alternative-to-using-cp.html">
Alternative to Using cp
</a></h3>
<!-- bashblog_timestamp: #202304242208.12# -->
<div class="subtitle">April 24, 2023 &mdash; 
Gregg Szumowski
</div>
<!-- text begin -->

<p>To backup files from a source directory to a backup directory:
<code>
$ mkdir /path/to/backup/directory
$ cd $HOME/source/directory
$ tar cf - . | (cd /path/to/backup/directory &amp;&amp; tar xBvf -)
</code>
Define the following alias:</p>

<p><code>
tar cvf - . | ( cd \!* ; tar xvf - )
</code></p>

<p>or as an alias:</p>

<p><code>
alias cpbytar='tar cvf - . | ( cd \!* ; tar xvf - )'
</code>
(The alias definition above is for Bash)</p>

<p>To do a recursive copy of a directory to another location, preserving the PERMISSIONS and OWNERSHIP of the files.  "cd" to the source location and invoke the following alias:</p>

<p><code>
cpbytar
</code></p>

<p>Tags: <a href='tag_cli.html'>cli</a>, <a href='tag_motd.html'>motd</a></p>
<!-- text end -->
</div>
<div id="footer">CC by-nc-nd <a href="http://twitter.com/gszumo">Gregg Szumowski</a> &mdash; <a href="mailto:gszumo[at]gmail[dot]com">gszumo[at]gmail[dot]com</a> &mdash; <a rel="me" href="https://mastodon.sdf.org/@gszumo">Mastodon</a><br/>
NOTE: All tips provided are USE AT YOUR OWN RISK. It is suggested that you read and test each tip in a non-volitile environment before placing into production.<br/>
Generated with <a href="https://github.com/cfenollosa/bashblog">bashblog</a>, a single bash script to easily create blogs like this one</div>
</div></div>
</body></html>
